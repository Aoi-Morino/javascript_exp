<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>javaScriptでのゲーム開発のすゝめ</title>
        <link
        href="https://fonts.googleapis.com/css2?family=M+PLUS+1+Code:wght@100..700&family=Noto+Sans+JP:wght@100..900&family=UoqMunThenKhung&family=WDXL+Lubrifont+SC&display=swap"
        rel="stylesheet"
        >
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
        >
        <link rel="stylesheet" href="main.css" />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-dark.css"
        >
        <script
        src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js">
        </script>
        <script>hljs.highlightAll();</script>

    </head>

<!-- *本文 -->
    <body>
        <div class="container">
            <h1><i class="fa-solid fa-gamepad"></i>JavaScriptでのゲーム開発のすゝめ</h1>
            <div class="p-block">
                <p>
                    本記事では、JavaScriptを使ったゲーム開発の方法を、実際のコードとゲーム画面のスクリーンショット
                    を織り交ぜながら、できるだけ再現しやすい形で解説していきます。
                </p>
                <p>
                    今回は、おそらく多くの方が一度は遊んだことのある<strong>マインスイーパ</strong>を題材に、実際にゲームを作成してい
                    きます。
                </p>
            </div>

            <img src="TemporaryIMG.jpg" alt="制作したマインスイーパの画像" width="90%" />

            <div class="p-block">
                <p>
                    マインスイーパを制作する際に参考にしたサイト：<a href="https://zenn.dev/alkn203/books/phina-tutorial-minesweeper/viewer/phina-tutorial-minesweeper-01">phina.js ゲーム作成解説 マインスイーパー</a>
                </p>
                <p>
                    <span class="underline-orange">※サイト内のコードを参考にしていますが、多少の改変を行っている場合があります。</span>
                </p>
            </div>


            <h2><i class="fa-solid fa-book"></i> 事前に知っておきたいこと <i class="fa-solid fa-book"></i></h2>
            <div class="p-block">
                <p>
                    プログラミングを学習する際には、あらかじめ前提知識を身につけておくことが、コードの理解において重
                    要です。
                </p>
                <p>そのため、まずはJavaScriptとHTML/CSSについて事前に学習しておきましょう。</p>
            </div>


            <h3>JavaScriptとは?</h3>
            <div class="p-block">
                <p>JavaScriptとは、Webページに動きをつける目的で開発されたプログラミング言語です。</p>
                <p>
                    Webブラウザの機能を制御し、動的な操作やアニメーション、ユーザーとのインタラクション、データの
                    検証や処理などを実現できます。
                </p>
            </div>
            <div class="p-block">
                <p>
                    HTMLやCSSと組み合わせて使用されることが多く、文字や画像にアニメーションをつけたり、Webペー
                    ジに高度な対話性や視覚効果を追加することができます。
                </p>
            </div>
            <div class="p-block">
                <p>
                    JavaScriptの特徴として、クロスプラットフォーム対応が挙げられます。つまり、異なるオペレーティン
                    グシステムや環境で動作するWebブラウザ上で、同じJavaScriptコードを実行できるということです。
                </p>
                <p>
                    この特性により、開発者は多様なデバイスやプラットフォームに対応したWebアプリケーションを効率的
                    に作成することができます。
                </p>
                <p>
                    また、比較的習得のしやすさに定評があるため、多くのプログラミング初学者が学習に励んでいます。
                </p>
            </div>


            <h3>HTML/CSSとは?</h3>
            <div class="p-block">
            <p>
                HTMLとは、「ハイパーテキスト・マークアップ・ランゲージ(Hyper Text Markup Language)」の略
                で、Webページを制作するためのマークアップ言語です。
            </p>
            <p>
                マークアップ言語とは、Webページ内のテキスト情報の構成（タイトル・段落など）や役割をコンピュー
                タが構造的に理解できるようにするための言語を意味します。
            </p>
            </div>
            <div class="p-block">
            <p>
                CSSとは、「カスケーディング・スタイル・シート(Cascading Style Sheets)」の略で、Webページのスタ
                イルを指定するためのスタイルシート言語です。
            </p>
            <p>スタイルシートとは、Webページに限らず、Wordなどで作成された文書のスタイルを制御する技術全般の
                ことを指します。</p>
            </div>
            <div class="p-block">
                <p>
                    もちろん、HTMLにも、&lt;color&gt;や&lt;font&gt;などの装飾目的のタグや属性があり、HTMLだけでウェブペー
                    ジのスタイルを制御することもできます。
                </p>
                <p>
                    しかし、HTMLは文書構造を定義するための言語であり、そこにスタイル関連の定義まで追加してしまう
                    と、HTMLファイルの文書構造が崩れてしまったり、後から修正が必要になった時もページ全てを見直
                    し、修正することが必要になります。
                </p>
                <p>
                    そんな時に、「スタイルに関してはあのCSSファイルを参照して」と、HTMLファイルに指定しておけ
                    ば、そのCSSファイル1つ修正すれば、参照しているHTMLファイルは、表示の確認を行うだけで済みま
                    す。
                </p>
            </div>
            <div class="p-block">
                <p>
                    JavaScriptを学習する際に、HTML/CSSが記述されていることも多いので、習得しておくことで
                    JavaScriptの学習にも役立ちます。エンジニアとしての活躍を目指す方は習得して損のないスキルです。
                </p>
            </div>


            <h3>JavaScriptでのゲーム開発で便利なライブラリ</h3>
            <div class="p-block">
                <p>ライブラリとは、使用頻度の多いプログラムを機能ごとにまとめたファイルのことです。</p>
                <p>
                    ライブラリを使わずにゲームを開発することもできますが、ゲーム開発に便利なライブラリを活用することで効率よく高品質のゲームを開発することができます。
                </p>
            </div>
            <div class="p-block">
                <p>
                    そこで、おすすめのavaScriptライブラリを3つ紹介します。ゲーム開発を行う場合、これらのライブラリ
                    をインストールして使い方を勉強していきましょう。
                </p>
            </div>


            <h4>phina.js</h4>
            <div class="p-block">
                <p>phina.jsは初心者におすすめのゲームライブラリです。</p>
                <p>
                    「アイデアをすぐに形にできる」をコンセプトとして開発されたため、初心者に優しくなっており、script
                    タグから読み込んだライブラリを組み合わせるだけでゲームを開発できます。
                </p>
            </div>
            <div class="p-block">
                <p>
                    また、phina.jsは日本で開発されたライブラリでドキュメントが日本語のため、分からない箇所を調べやす
                    く、phina.jsについて書かれた日本語のサイトも豊富にあるため、初心者の方はまずはphina.jsから始めて
                    みましょう。
                </p>
                <p>
                    <span class="underline-orange">今回は、このphina.jsを利用して開発していきます。</span>
                </p>
            </div>
            <div class="p-block">
                <p>参考：<a href="https://phinajs.com/">phina.js</a></p>
            </div>

            <img src="image\phina-js_img.png" alt="phina.jsのイメージ" width="90%" />


            <h4>Phaser.js</h4>
            <div class="p-block">
                <p>
                    Phaser.jsは代表的なゲームライブラリであり、2Dゲーム開発において多くのエンジニアに使われている人
                    気のライブラリです。
                </p>
            </div>
            <div class="p-block">
                <p>豊富な機能を無料で利用できるため、初心者でも利用ハードルが低いのが特徴です。</p>
                <p>また、有料のプラグインを購入することで機能を追加することもできます。</p>
            </div>
            <div class="p-block">
                <p>
                    また、Phaser.jsはコミュニティが活発なライブラリでもあり、バージョンの更新が継続して行われている
                    ため、多くのゲーム開発者に愛用されていることが分かります。
                </p>
            </div>
            <div class="p-block">
                <p>参考：<a href="https://phaser.io/">Phaser.js</a></p>
            </div>

            <img src="image\phaser-io_img.png" alt="Phaser.jsのイメージ" width="90%" />


            <h4>PixiJS</h4>
            <div class="p-block">
                <p>PixiJSは、2D視覚化に特化した絵画ライブラリです。</p>
            </div>
            <div class="p-block">
                <p>
                    ゲーム開発専用で作られてはいませんが、グラフィック処理の高速化が可能となるためゲーム開発の現場でよく使われています。
                </p>
            </div>
            <div class="p-block">
                <p>参考：<a href="https://pixijs.com/">PixiJS</a></p>
            </div>

            <img src="image\pixi-js_img.png" alt="PixiJSのイメージ" width="90%" />


            <h2><i class="fa-solid fa-code"></i> ゲームの開発 <i class="fa-solid fa-code"></i></h2>
            <div class="p-block">
                <p>
                    それでは、ここから実際に、phina.jsを利用してマインスイーパを開発していきましょう。
                </p>
                <p>
                    いくつかの機能に分けて実装し、さらに実装したコードを細かく分割して説明していきます。
                </p>
            </div>


            <h3>パネルの実装と配置</h3>
            <div class="p-block">
                <p>
                    ここでは、下のスクリーンショットのようにパネルを並べていきます。
                </p>
            </div>

            <img src="image\Panel-placement.png" alt="タイルを並べたスクリーンショット" width="40%" />

            <div class="p-block">
                <p>
                    初めに、ファイルをまとめるプロジェクトフォルダと、ウェブページの土台となるHTMLファイルを用意
                    しましょう。
                </p>
            </div>
            <div class="p-block">
                <p>
                    まず、PCの好きな場所にフォルダを新規作成してください。フォルダ名は、ハイフン（-）やアンダーバー
                    （_）以外の特殊記号や空白が含まれていなければ基本自由です。
                </p>
                <p>
                    次に、作成したフォルダを右クリックし、メニューから <strong>Code で開く</strong>を選択すると、VSCodeが開かれ、制
                    作したフォルダが表示されます。（※もし Code で開く が表示されない場合は、VSCodeを起動してから
                    フォルダをウィンドウ内に直接ドラッグ＆ドロップしてください）
                </p>
                <p>
                    そして、左上あたりにマウスを持っていくと表示される、<strong>新しいファイルの作成</strong>ボタン（<i class="fa-solid fa-file-circle-plus"></i> のようなボタ
                    ン）をクリックし、 index.html という名前でHTMLファイルを新規作成しましょう。このファイル名は、
                    他の名前でも問題はありませんが、GitHub Pages等でウェブサイトを公開する際は、この名前にしておく
                    必要があります。
                </p>
                <p>
                    その後、<a href="https://phinajs.com/">phina.jsの公式サイト</a>にある以下のコードをコピーし、先ほど作成した index.html ファイルに貼
                    り付け（ペースト）してください。
                </p>
                <pre><code class="language-html">&lt;!doctype html&gt;

&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&#039;utf-8&#039; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&gt;
    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;

    &lt;title&gt;Getting started | phina.js&lt;/title&gt;
    &lt;!-- phina.js を読み込む --&gt;
    &lt;script src=&#039;http://cdn.rawgit.com/phi-jp/phina.js/v0.2.0/build/phina.js&#039;&gt;&lt;/script&gt;

    &lt;!-- メイン処理 --&gt;
    &lt;script src=&#039;main.js&#039;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;/body&gt;
&lt;/html&gt;</code></pre>
            </div>

            <div class="p-block">
                <p>次は、実際にパネルを表示するための処理を、JavaScriptファイルに記述していきましょう。</p>
            </div>
            <div class="p-block">
                <p>
                    index.html を作成したときと同様に、今度は main.js という名前でJavaScriptファイルを新規作成しまし
                    ょう。
                </p>
                <p>
                    このファイル名は、 index.html 内で読み込むファイル名として指定されています。そのため、もしファイ
                    ル名を変更したい場合は、 index.html の内容も同時に変更する必要があります。なので、今回は main.js 
                    のまま進めることをおすすめします。
                </p>
                <p>
                    ファイルの準備ができたら、次に示すコードをコピーし、作成したmain.jsに貼り付け（ペースト）してく
                    ださい。
                </p>
                <pre><code class="language-js">// phina.js をグローバル領域に展開
phina.globalize();

// 定数
var GRID_SIZE = 70; // グリッドのサイズ
var SCREEN_SPACE = 10; // 画面左右の空白
var PANEL_NUM_X = 9; // 横のパネル数
var PANEL_NUM_Y = 10; // 縦のパネル数
var SCREEN_WIDTH = GRID_SIZE * PANEL_NUM_X + SCREEN_SPACE // 画面横サイズ
var SCREEN_HEIGHT = GRID_SIZE * (PANEL_NUM_Y + 2); // 画面縦サイズ
var PANEL_SIZE = GRID_SIZE * 0.9; // パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + SCREEN_SPACE) / 2; // オフセット値

// メインシーン
phina.define('MainScene', {
  superClass: 'DisplayScene',
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = '#808080'; // ≒'gray'
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
      });
    });
  },
});

// パネルクラス
phina.define('Panel', {
  // RectangleShapeを継承
  superClass: 'RectangleShape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: '#c0c0c0', // 塗りつぶし色 ≒'silver'
        stroke: '#ffffff', // 枠の色 ≒'white'
        cornerRadius: 2, // 角の丸み
      });
    },
});

// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: 'main', // メイン画面からスタート
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });
  app.run();
});</code></pre>
            </div>
            <div class="p-block">
                <p>それでは、このコードを分解して、一つ一つどのような役割を持っているのか、見ていきましょう。</p>
            </div>


            <h4>phina.jsのセットアップ</h4>
            <div class="p-block">
                <pre><code class="language-js">// phina.js をグローバル領域に展開
phina.globalize();</code></pre>
                <p>これは、phina.jsを使いやすくするための<strong>おまじない</strong>です。</p>
                <p>
                    この一行を記述しておくことにより、 phina.define や DisplayScene といった phina.js の便利な機能
                    を、 phina. を省略して記述することができます。
                </p>
            </div>


            <h4>定数の定義</h4>
            <div class="p-block">
                <pre><code class="language-js">// 定数
var GRID_SIZE = 70; // グリッドのサイズ
var SCREEN_SPACE = 10; // 画面端の空白
var PANEL_NUM_X = 9; // 横のパネル数
var PANEL_NUM_Y = 10; // 縦のパネル数
var SCREEN_WIDTH = GRID_SIZE * PANEL_NUM_X + SCREEN_SPACE // 画面横サイズ
var SCREEN_HEIGHT = GRID_SIZE * (PANEL_NUM_Y + 2) + SCREEN_SPACE; // 画面縦サイズ
var PANEL_SIZE = GRID_SIZE * 0.9; // パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + SCREEN_SPACE) / 2; // オフセット値</code></pre>
                <p>
                    ここでは、プログラムの中で何度も使われる基本的な値を定義しています。このような、<strong>あとから変更しな
                    い値</strong>を「定数」と呼びます。
                </p>
                <p>
                    このような定数を使う理由は、例えば、後から横のパネルの数を9枚から5枚に変更したいと思ったとき、
                    PANEL_NUM_X の値を9から5に変更するだけで、関連する画面サイズなども自動で計算し直されるた
                    め、簡単にゲームに反映させることができるからです。
                </p>
            </div>
            <div class="p-block>">
                <p>それでは、この定義した定数を、一つずつ詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">var GRID_SIZE = 70; // グリッドのサイズ</code></pre>
                <p>グリッドの一辺の長さを70ピクセルに設定しています。</p>
                <p>
                    この値は、画面全体のレイアウト設計の土台となる最も重要な定数であり、この値を変更することにより、
                    ゲーム全体のスケール（縮尺）を変更することができます。
                </p>
                <p>
                    ただし、ほかのほとんどの値がこのGRID_SIZEを基準にしているため、安易に変更すると意図しない表示
                    崩れが起きる可能性があります。特別な理由がない限り、この値は変更せずに進めましょう。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">var SCREEN_SPACE = 10; // 画面端の空白</code></pre>
                <p>画面端とパネル群との隙間を10ピクセルに設定しています。</p>
                <p>
                    これは、画面を見やすくするために定義しています。この値が0だと、パネルが画面端に密着し、窮屈に見
                    えてしまいます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">var PANEL_NUM_X = 9; // 横のパネル数
var PANEL_NUM_Y = 10; // 縦のパネル数</code></pre>
                <p>それぞれ、横と縦に何個パネルを並べるかを設定しています。</p>
                <p>この場合は、横に9個、縦に10個なので、9×10の盤面がつくられます。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">var SCREEN_WIDTH = GRID_SIZE * PANEL_NUM_X + SCREEN_SPACE// 画面横サイズ</code></pre>
                <p>ゲーム画面の横幅を計算しています。</p>
                <p>
                    まず、 GRID_SIZE×PANEL_NUM_X でパネルを9枚並べられるだけの横幅を求めます。そこに左右の余
                    白を確保するため、 SCREEN_SPACE を加算し、最終的な画面の横幅を決めています。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">var SCREEN_HEIGHT = GRID_SIZE * (PANEL_NUM_Y + 2) + SCREEN_SPACE; // 画面縦サイズ</code></pre>
                <p>ゲーム画面の縦の高さを計算しています。</p>
                <p>
                    PANEL_NUM_Y + 2 の部分で、画面の下に様々な情報などを表示するために、パネル2つ分のスペースを
                    確保しています。また、 SCREEN_SPACEを加算し、上下の余白も確保しています。
                </p>
                <p>本セッションでは例として、パネル2枚（つまり固定値）分のスペースを確保する方式で進めます。</p>
                <p>
                    この方式のほかに、パネル全体の高さに対する一定の比率分のスペースを確保する方式があります。その場
                    合は、GRID_SIZE * PANEL_NUM_Y * 1.3 のように、特定の数値を掛けることにより実現できます。この
                    方式の特徴は、パネルの縦の総数に応じて確保されるスペースの高さも変動する点です。
                </p>
                <p>なお、次のセッションからは、こちらの比率で指定する方式で進めていきます。</p>
            </div>
            <div class="p-block">
                <p>下の画像は、この方法で * 1.3（30%分）のスペースを確保した例です。</p>
                <div class="row-img">
                <img src="image\panel_1-3.png" alt="縦10マスで1.3倍した時のスペース" height=600 />
                <img src="image\panel_1-3plus.png" alt="縦20マスで1.3倍した時のスペース" height=600 />
                </div>
                <p>
                    <span class="underline-orange">
                        なお、比率で指定する場合、1未満の値を掛けるとパネル表示領域が削られてしまうので、必ず1以上の数
                        値にするようにしてください。
                    </span>
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">var PANEL_SIZE = GRID_SIZE * 0.9; // パネルの大きさ</code></pre>
                <p>パネル自体の大きさを計算しています。</p>
                <p>
                    パネルを配置する基準となるグリッドのサイズ（GRID_SIZE）に対して少し小さく（90%の大きさに）設
                    定しています。こうすることで、パネル同士の間に適度な隙間が生まれ、一つ一つのパネルが区別しやすく
                    なります。
                </p>
                <p>また、0.9 の値を小さくすることでパネルも小さくなり、相対的にパネル同士の隙間は広がります。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">var PANEL_OFFSET = (GRID_SIZE + SCREEN_SPACE) / 2; // オフセット値</code></pre>
                <p>パネルを配置する際の、<strong>基準点からのズレ</strong>を補正するための値を計算しています。</p>
                <p>
                    phina.jsのグリッド機能は、各グリッドの左上を基準に座標を決めています。しかし、今回はパネルをグリ
                    ッドの中心に配置したいため、そのズレを補正する必要があります。この PANEL_OFFSET は、そのため
                    の補正値です。
                </p>
            </div>
            <div class="p-block">
                <p>
                    具体的には、グリッド（GRID_SIZE）の半分の大きさだけ右下にずらすことで中心合わせができます。今
                    回はさらに画面全体の余白（SCREEN_SPACE）も考慮し、その値を加算してから半分にし、最終的なオ
                    フセット値を算出しています。
                </p>
            </div>


            <h4>メインシーン (MainScene)</h4>
            <div class="p-block">
                <pre><code class="language-js">// メインシーン
phina.define('MainScene', {
  superClass: 'DisplayScene',
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = '#808080'; // ≒'gray'
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
      });
    });
  },
});</code></pre>
                <p>ここは、ゲームのメイン画面を定義している部分です。</p>
                <p>
                    phina.jsでは、ゲームの各場面をシーン (Scene) という単位で管理します。今回定義している MainScene
                    もその一つです。
                </p>
            </div>
                <div class="p-code">
                <p>参考までに、デフォルトで用意されているシーンを以下に示します。</p>
                <ul>
                    <li>SplashScene（スプラッシュシーンと呼ばれている、ゲーム起動時に表示されるシーン）</li>
                    <li>TitleScene（タイトル画面。デフォルトだとこの画面が表示される）</li>
                    <li>MainScene（ゲームのメインシーン。今回定義しているもの）</li>
                    <li>ResultScene</li>
                </ul>
                <p>
                    今回はこの MainScene の中で、画面の大きさや背景色、そしてパネルの配置といった、ゲーム画面の初期
                    設定を行っています。
                </p>
            </div>
            <div class="p-block">
                <p>それでは、今度はこの MainScene の設計図を、一行ずつ詳しく見ていきましょう</p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">phina.define('MainScene', {</code></pre>
                <p>これからMainSceneという名前の新しい「クラス（設計図）」を定義します、という宣言です。</p>
                <p>
                    phina.define が、phina.jsでクラスを定義するための命令になります。第1引数の 'MainScene' で記述す
                    るクラス名を表し、第2引数の { ... } の中に、そのクラスの具体的な中身（プロパティやメソッド）を記述
                    していきます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">  superClass: 'DisplayScene',</code></pre>
                <p>
                    MainSceneは、phina.jsがもともと持っているDisplayScene（画面表示の基本機能を持つクラス）を元に
                    して作る、という指定です。
                </p>
                <p>
                    DisplaySceneには、画面に何かを表示するための基本的な機能（例えば、背景色を変えるなど）がすべて
                    詰まっています。このように、既存のクラスの機能を引き継いで新しいクラスを作ることを「継承（けいし
                    ょう）」と呼びます。
                </p>
                <p>
                    継承のおかげで、私たちは画面表示の基本機能をゼロから作る必要がなく、ゲーム開発の面白い部分に集中
                    できるのです。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">// コンストラクタ
  init: function() {</code></pre>
                <p>
                    このinitは、MainSceneクラスの**コンストラクタ（初期化処理）**です。
                </p>
                <p>
                    MainSceneのインスタンス（実体）が生成される際に、一番最初に一度だけ実行される特別な関数で、こ
                    の中に画面の準備など、初期設定に関するコードを記述します。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });</code></pre>
                <p>元にした親クラス（DisplayScene）の初期化処理を呼び出しています。</p>
                <p>
                    これをする理由は、親クラスの機能を引き継いだ場合、まずthis.superInit()を呼び出して親クラス自身に
                    準備をさせないと、継承した機能がうまく動作しないことがあるからです。
                </p>
            </div>
            <div class="p-block">
                <p>
                    また、このsuperInitを呼び出す際に、引数として { ... } を渡すことで、親クラスに様々な設定を伝えるこ
                    とができます。
                </p>
                <p>
                    ここでは、先ほど定義した定数 SCREEN_WIDTH と SCREEN_HEIGHT を渡し、このシーンの画面サイ
                    ズを設定しています。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">    // 背景色
    this.backgroundColor = '#808080'; // ≒'gray'</code></pre>
                <p>
                    this.backgroundColorプロパティに値を設定することで、このシーンの背景色を灰色(#808080 ≒ gray)
                    に設定しています。
                </p>
                <p>
                    この値をカラーコードと言い、カラーコードを書き換えることにより、背景色を自由に変更することができ
                    ます。
                </p>
                <p>例えば、'#000000'とすれば黒色になります。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);</code></pre>
                <p>
                    パネルを等間隔に配置するための便利な道具（Gridオブジェクト）を作成しています。この grid は、X座
                    標とY座標の両方の計算に使える、非常に強力なツールです。
                </p>
                <p>
                    また、この grid という変数を使えば、後ほど説明するように grid.span(i) と書くだけでi番目のマス目の
                    座標を簡単に取得できます。
                </p>
                <p>
                    GRID_SIZE * PANEL_NUM_X でグリッド全体の幅を指定し、 PANEL_NUM_X でグリッドを何分割する
                    かを指定しています。（今回の場合は、横方向に9分割）
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">    // グループ
    var panelGroup = DisplayElement().addChildTo(this);</code></pre>
                <p>
                    これからたくさん作るパネルをまとめて管理するための、「グループ」を作成しています。パソコンで言う
                    ところの<strong>フォルダ</strong>のようなものだと考えるとわかりやすいでしょう。
                </p>
            </div>
            <div class="p-block">
                <p>この一行は、実は2つの処理を.で連結して実行しています。</p>
                <p>
                    まず、DisplayElement()で空のグループ（表示要素）を作成しています。その次に、.addChildTo(this)
                    で、作成したグループをこのシーン（this）に追加しています。
                </p>
            </div>
            <div class="p-block">
                <p>このようにシーンにグループを追加することで、グループ内のパネルが画面に表示されるようになります。</p>
                <p>今後、このpanelGroupに各パネルを追加していくことになります。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {</code></pre>
                <p>n.times( ... )は、中の処理をn回繰り返す処理です。</p>
                <p>
                    n.times(function(i) { ... }) と書くと、{ ... } の中の処理をn回繰り返します。またその際、変数 i には0か
                    らn-1までの数値が順番に入ります。
                </p>
                <p>ここでは、この処理を利用し、盤面のマス目一つ一つにパネルを配置していきます。</p>
            </div>
            <div class="p-block">
                <p>
                    今回の場合は、 PANEL_NUM_X は 9 、 PANEL_NUM_Y は 10 となり、またそれが重なっている（二重
                    ループ）ので、「10回繰り返す処理」を「9回繰り返す」ことになり、合計 9 x 10 = 90回処理が実行され
                    ます。
                </p>
                <p>
                    また、spanXには0から8までの数字が、spanYには0から9までの数字が順番に入ります。これにより、盤
                    面のすべてのマス目（今回の場合は、(0,0), (0,1), ..., (8,9)）に対して処理を行うことができます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">        // パネル作成
        var panel = Panel().addChildTo(panelGroup);</code></pre>
                <p>panel()で、後ほど定義するパネルの設計図から、実際のパネルを1つずつ作成しています。</p>
                <p>
                    また、作成したパネルを.addChildTo(this)でシーンに直接追加するのではなく、
                    .addChildTo(panelGroup)でグループに追加しています。
                </p>
                <p>
                    こうすることにより、90個のパネルがpanelGroupという一つの<strong>フォルダ</strong>にまとめられ、後で一括管理でき
                    るようになるのです。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;</code></pre>
                <p>作成したパネルのX座標（横の位置）とY座標（縦の位置）を設定し、正しく配置しています。</p>
                <p>
                    grid.span(spanX)では、先ほど作成したgridオブジェクトを使い、spanX番目（0〜8番目）のグリッドの
                    X座標を取得します。
                </p>
                <p>
                    また、計算された座標にオフセット値を足すことで、パネルがグリッドの中央に来るように微調整していま
                    す。
                </p>
                <p>panel.yも同様に、縦の位置を設定しています。</p>
            </div>
            <div class="p-block">
                <p>ここで、Y座標の計算にも、X軸用に作ったgridを使い回して大丈夫なのか疑問に思うかもしれません。</p>
                <p>
                    しかし、.phina.jsの Grid は賢く、grid.span(i) という命令は、単純に「i番目のマス目の位置」を計算し
                    て返すだけです。その「1マスあたりのサイズ」は、X方向もY方向も同じ GRID_SIZE なので、X軸用に作
                    ったグリッドを、そのままY座標の計算に使っても全く問題ないのです。
                </p>
            </div>


            <h4>パネルクラス (Panel)</h4>
            <div class="p-block">
                <pre><code class="language-js">// パネルクラス
phina.define('Panel', {
  // RectangleShapeを継承
  superClass: 'RectangleShape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: '#c0c0c0', // 塗りつぶし色 ≒'silver'
        stroke: '#ffffff', // 枠の色 ≒'white'
        cornerRadius: 2, // 角の丸み
      });
    },
});</code></pre>
                <p>ここは、パネル1つ1つの見た目や動きを定義する、Panelクラス（設計図）を作成する部分です。</p>
                <p>
                    MainSceneの時と同様に、phina.defineでクラスを定義し、superClassで親クラスを指定、initで初期化
                    処理を記述する、という構成になっています。
                </p>
            </div>
            <div class="p-block">
                <p>このクラスで、パネルの色や形、大きさといった、基本的なスタイルを設定していきます。</p>
                <p>それでは、つぎにこの panel の設計図を、一行ずつ詳しく見ていきましょう</p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">// パネルクラス
phina.define('Panel', {</code></pre>
                <p>
                    先ほど MainScene の中で、 var panel = Panel() というコードを書きましたが、そのPanel()とは何か
                    を、ここで定義しています。
                </p>
                <p>
                    MainScene の時と同様に、 phina.define を利用し、 Panel という名前の新しいクラス（設計図）を定義
                    しています。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">  // RectangleShapeを継承
  superClass: 'RectangleShape',</code></pre>
                <p>
                    MainScene が DisplayScene を継承したのと同様に、 Panel クラスは RectangleShape というクラスを
                    継承しています。
                </p>
            </div>
            <div class="p-block">
                <p>
                    RectangleShapeは、その名の通り、四角形を描画するための基本的な機能（例えば、大きさや色、枠線な
                    どを設定する機能）をすべて持っています。
                </p>
                <p>
                    このクラスを継承することで、私たちは面倒な描画処理を自分で書く必要がなく、簡単に四角形（パネル）
                    を表示できるのです。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">    // コンストラクタ
    init: function() {</code></pre>
                <p>
                    MainSceneの時と同様に、一番最初に一度だけ、init関数でPanelクラスのコンストラクタ（初期化処理）
                    を行っています。
                </p>
                <p>この中に、パネルの大きさや色といった、基本的な見た目に関する初期設定を記述していきます。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: '#c0c0c0', // 塗りつぶし色 ≒'silver'
        stroke: '#ffffff', // 枠の色 ≒'white'
        cornerRadius: 2, // 角の丸み</code></pre>
                <p>
                    MainSceneの時と同様に、親クラス（RectangleShape）の初期化処理（superInit）を呼び出していま
                    す。
                </p>
                <p>
                    この際に、引数として { ... } の中に設定情報を渡すことで、描画される四角形の見た目を細かく指定するこ
                    とができます。今回は、以下のように設定しています。
                </p>
                <ul>
                    <li>width, height：パネルの大きさを、先ほど定義したPANEL_SIZEに設定。</li>
                    <li>fill：塗りつぶしの色を銀色（#c0c0c0 ≒ silver）に設定。</li>
                    <li>stroke：枠線の色を白（#ffffff ≒ white）に設定。</li>
                    <li>cornerRadius：角を2ピクセル分丸く設定。</li>
                </ul>
                <p>これらの値を変更することにより、パネルの見た目を自由にカスタマイズすることができます。</p>
            </div>


            <h4>メイン処理 (ゲームの起動)</h4>
            <div class="p-block">
                <pre><code class="language-js">// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: 'main', // メイン画面からスタート
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });
  app.run();
});</code></pre>
                <p>
                    ここは、最後にこれまで定義してきた定数やクラス（MainScene, Panel）を組み合わせて、一つのゲーム
                    アプリケーションとして起動するための部分です。
                </p>
                <p>
                    このコードがあって初めて、私たちが作ったマインスイーパが実際に画面に表示され、動作するようになり
                    ます。
                </p>
                <p>それでは、このメイン処理の中身を、一行ずつ詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">phina.main(function() {</code></pre>
                <p>
                    HTMLページの読み込みがすべて完了したら、{ ... } の中の処理を実行するという、phina.jsの基本的なお
                    まじないです。
                </p>
                <p>
                    この一行を記述しておかないと、HTML側の準備が整う前にJavaScriptがゲームの描画を始めてしまい、
                    「描画する場所（キャンバス）がありません」といったようなエラーが起こる可能性があります。
                </p>
                <p>
                    なので、確実に準備が整ってからゲームを開始するために、すべての起動処理をこのphina.mainの中に記
                    述します。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-js">  var app = GameApp({
    startLabel: 'main', // メイン画面からスタート
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });</code></pre>
                <p>GameAppでゲームアプリケーション本体を作成し、appという変数に格納しています。</p>
                <p>
                    その際、引数として { ... } の中に、アプリケーションの基本的な設定情報を渡しています。今回は、以下の
                    ように設定しています。
                </p>
                <ul>
                    <li>startLabel: 'main'：ゲーム開始時、最初にMainSceneを表示する。</li>
                    <li>width, height: ゲーム全体の画面サイズを先ほど求めた定数に。</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code class="language-js">  app.run();</code></pre>
                <p>最後に、先ほど作成したゲームアプリケーションを起動（スタート）しています。</p>
                <p>
                    この一行が実行された瞬間に、私たちの作ったマインスイーパが画面に表示され、ゲームがスタートしま
                    す。
                </p>
            </div>
            <div class="p-block">
                <p>これで、パネルを画面に配置することができました。</p>
                <p>次のステップとして、この盤面にランダムに爆弾を配置する処理を追加していきます。</p>
            </div>


            <h3>爆弾の配置</h3>
            <div class="p-block">
                <p>ここでは、下のスクリーンショットのように、配置したパネルにランダムに爆弾を仕掛けていきます。</p>
            </div>
            <div class="p-block">

            <img src="image\bomb-placement.png" alt="爆弾を配置したスクリーンショット" width="40%" />

                <p>
                    以下は、爆弾を配置するために、これまでのコードにいくつかの追加と、それに伴う変更を加えたコードで
                    す。コード内の//* 追加や//* 変更と書かれた部分が、今回の変更点です。
                </p>
                <pre><code class="language-javascript">// phina.js をグローバル領域に展開
phina.globalize();

// 定数
var GRID_SIZE = 70; // グリッドのサイズ
var SCREEN_SPACE = 10; // 画面端の空白
var PANEL_NUM_X = 9; // 横のパネル数
var PANEL_NUM_Y = 10; // 縦のパネル数
var PANEL_MARGIN_RATIO = 1.3; //* 追加：画面縦の空白の割合
var PANEL_SIZE_RATIO = 0.9; //* 追加：パネル大きさの割合
var BOMB_NUM = 10; //* 追加：爆弾数
var SCREEN_WIDTH = GRID_SIZE * PANEL_NUM_X + SCREEN_SPACE// 画面横サイズ
var SCREEN_HEIGHT = GRID_SIZE * PANEL_NUM_Y * PANEL_MARGIN_RATIO + SCREEN_SPACE; //* 変更：画面縦サイズ
var PANEL_SIZE = GRID_SIZE * PANEL_SIZE_RATIO; //* 変更：パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + SCREEN_SPACE) / 2; // オフセット値

// メインシーン
phina.define('MainScene', {
  superClass: 'DisplayScene',
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = '#808080'; // ≒'gray'
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    //* 追加：爆弾位置をランダムに決めた配列を作成
    var bombs = [];
    (PANEL_NUM_X * PANEL_NUM_Y).times(function() {
      bombs.push(false);
    });
    bombs.fill(true, 0, BOMB_NUM).shuffle();
    //* ここまで
    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
        //* 追加：パネルに爆弾情報を紐づける
        panel.isBomb = bombs[spanX * PANEL_NUM_Y + spanY];
        // 爆弾なら表示
        if (panel.isBomb) Bomb().addChildTo(panel);
        //* ここまで
      });
    });
  },
});

// パネルクラス
phina.define('Panel', {
  // RectangleShapeを継承
  superClass: 'RectangleShape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: '#c0c0c0', // 塗りつぶし色 ≒'silver'
        stroke: '#ffffff', // 枠の色 ≒'white'
        cornerRadius: 2, // 角の丸み
      });
    },
});

//* 追加：爆弾クラス
phina.define('Bomb', {
  // Shapeを継承
  superClass: 'Shape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: GRID_SIZE,
        height: GRID_SIZE,
        backgroundColor: 'transparent',
      });
      // 導線
      RectangleShape({
        width: PANEL_SIZE / 8,
        height: PANEL_SIZE / 8,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
        y: -20,
      }).addChildTo(this);
      // 本体
      CircleShape({
        radius: PANEL_SIZE / 4,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
      }).addChildTo(this);
    },
});
//* ここまで

// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: 'main', // メイン画面からスタート
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });
  app.run();
});</code></pre>
                <p>このコードをコピーし、 main.jsに上書き、あるいは変更点を追記してください。</p>
            </div>
            <div class="p-block">
                <p>それでは、追加・変更した要素がどのような役割を持っているのか、詳しく見ていきましょう。</p>
            </div>
            <div class="p-block">
                <p>
                    <span class="underline-orange">
                        注：以降のコード解説では、既存のコードに変更を加える場合に、その変更点を分かりやすく示すためDiff
                        形式を使用します。（全く新しいコードブロックを追加する場合は、通常の形式で表示します。）それぞ
                        れ、行頭に + が付いている行は追加された行、 - が付いている行は削除された行を表しています。
                    </span>
                </p>
                <p>
                    <span class="underline-orange">
                        この + や - は、あくまで説明のための記号です。コードをコピーし、貼り付け（ペースト）する際は、 +
                        の記号のついた行の内容を追加し、 - の記号のついた行の内容は削除してください。
                    </span>
                </p>
            </div>


            <h4>追加・変更部分の確認 - 定数の定義</h4>
            <div class="p-block">
                <pre><code class="language-Diff">// 定数
var GRID_SIZE = 70; // グリッドのサイズ
var SCREEN_SPACE = 10; // 画面端の空白
var PANEL_NUM_X = 9; // 横のパネル数
var PANEL_NUM_Y = 10; // 縦のパネル数
+ var PANEL_MARGIN_RATIO = 1.3; //* 追加：画面縦の空白の割合
+ var PANEL_SIZE_RATIO = 0.9; //* 追加：パネル大きさの割合
+ var BOMB_NUM = 10; //* 追加：爆弾数
var SCREEN_WIDTH = GRID_SIZE * PANEL_NUM_X + SCREEN_SPACE// 画面横サイズ
- var SCREEN_HEIGHT = GRID_SIZE * (PANEL_NUM_Y + 2) + SCREEN_SPACE; //* 変更前：画面縦サイズ
- var PANEL_SIZE = GRID_SIZE * 0.9; //* 変更前：パネルの大きさ
+ var SCREEN_HEIGHT = GRID_SIZE * PANEL_NUM_Y * PANEL_MARGIN_RATIO + SCREEN_SPACE; //* 変更後：画面縦サイズ
+ var PANEL_SIZE = GRID_SIZE * PANEL_SIZE_RATIO; //* 変更後：パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + SCREEN_SPACE) / 2; // オフセット値</code></pre>
                <p>この部分では、いくつかの追加要素と、変更を行っています。</p>
                <p>まず、爆弾の数を管理する定数を追加しています。</p>
                <p>
                    次に、前回のセッションで「次回から使う」と予告した、比率でレイアウトを計算する方法にコードを修正
                    しています。
                </p>
            </div>
            <div class="p-block">
                <p>それでは、それぞれ抜粋し、詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+ var PANEL_MARGIN_RATIO = 1.3; //* 追加：画面縦の空白の割合</code></pre>
                <p>
                    これは、前回のセッションで学んだ「比率でスペースを確保する方法」で使う、比率の値を定数として定義
                    したものです。
                </p>
                <p>
                    このように定数にしておくことにより、画面下部の余白の割合を変更する際、この一行の数値を変更するだ
                    けで済むようになります。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+ var PANEL_SIZE_RATIO = 0.9; //* 追加：パネル大きさの割合</code></pre>
                <p>
                    パネルの大きさを計算する際に使う縮小率（0.9）を、PANEL_SIZE_RATIOという名前の定数にしたもの
                    です。
                </p>
                <p>
                    PANEL_MARGIN_RATIO の時と同様、定数にしておくことにより、縮小率を変更する際、この一行の数
                    値を変更するだけで済むようになります。
                </p>
            </div>
            <div class="p-block">
                <p>またそれだけでなく、コードの可読性（分かりやすさ）が向上するというメリットがあります。</p>
                <p>
                    実際、PANEL_SIZE = GRID_SIZE * 0.9 と書くよりも、 PANEL_SIZE = GRID_SIZE *
                    PANEL_SIZE_RATIO と書く方が、「グリッドサイズにパネルサイズの比率を掛けているんだな」と、コ
                    ードがその意味を語ってくれるようになります。
                </p>
                <p>
                    このように、コード中に直接書かれた意味の読み取れない数値（マジックナンバー）を、意味のある名前の
                    定数に置き換えるのは、読みやすく、メンテナンスしやすいコードを書くための基本です。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+ var BOMB_NUM = 10; //* 追加：爆弾数</code></pre>
                <p>
                    パネルに仕込む爆弾の数を設定しています。この値を変更するだけで、ゲームの難易度を簡単に調整できま
                    す。
                </p>
                <p>この場合は、90個のパネルのうち、ランダムな10個のパネルに爆弾が仕込まれます。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">- var SCREEN_HEIGHT = GRID_SIZE * (PANEL_NUM_Y + 2) + SCREEN_SPACE; //* 変更前：画面縦サイズ
- var PANEL_SIZE = GRID_SIZE * 0.9; //* 変更前：パネルの大きさ
+ var SCREEN_HEIGHT = GRID_SIZE * PANEL_NUM_Y * PANEL_MARGIN_RATIO + SCREEN_SPACE; //* 変更：画面縦サイズ
+ var PANEL_SIZE = GRID_SIZE * PANEL_SIZE_RATIO; //* 変更：パネルの大きさ</code></pre>
                <p>
                    先ほど追加した PANEL_MARGIN_RATIO と PANEL_SIZE_RATIO を使い、 SCREEN_HEIGHT と
                    PANEL_SIZE の計算式をそれぞれ変更しています。
                </p>
                <p>
                    これにより、* 1.3や* 0.9といったマジックナンバーがコードから排除され、PANEL_MARGIN_RATIO
                    （マージンの比率）やPANEL_SIZE_RATIO（サイズの比率）といった、意味の分かる名前で計算式を記
                    述できるようになりました。
                </p>
            </div>


            <h4>追加部分の確認 - メインシーン (MainScene)</h4>
            <div class="code-block">
                <pre><code class="language-Diff">// メインシーン
phina.define('MainScene', {
  superClass: 'DisplayScene',
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = '#808080'; // ≒'gray'
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
+     //* 追加：爆弾位置をランダムに決めた配列を作成
+     var bombs = [];
+     (PANEL_NUM_X * PANEL_NUM_Y).times(function() {
+       bombs.push(false);
+     });
+     bombs.fill(true, 0, BOMB_NUM).shuffle();
+     //* ここまで
    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
+         //* 追加：パネルに爆弾情報を紐づける
+         panel.isBomb = bombs[spanX * PANEL_NUM_Y + spanY];
+         // 爆弾なら表示
+         if (panel.isBomb) Bomb().addChildTo(panel);
+         //* ここまで
      });
    });
  },
});</code></pre>
                <p>この部分では、いくつかの追加を行っています。</p>
                <p>まず、爆弾の位置を管理する配列を追加し、実際に爆弾の位置を決定しています。</p>
                <p>次に、その情報に基づき、パネルが爆弾かどうかを判定し、パネルに爆弾の情報を紐づけています。</p>
            </div>
            <div class="p-block">
                <p>それでは、それぞれ抜粋し、詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     //* 追加：爆弾位置をランダムに決めた配列を作成
+     var bombs = [];
+     (PANEL_NUM_X * PANEL_NUM_Y).times(function() {
+       bombs.push(false);
+     });</code></pre>
                <p>どのパネルが爆弾になるかという情報を管理するための配列（bombs）を準備しています。</p>
                <p>具体的には、まずvar bombs = []; で空っぽの配列（情報を入れる箱）を用意しています。</p>
                <p>
                    次に、timesメソッドを使って、その配列の中にパネルの総数（90個）分のfalse（否定を意味します。今
                    回の場合は、爆弾ではないという意味になります。）を詰め込んでいきます。
                </p>
            </div>
            <div class="p-block">
                <p>これで、「まだ一つも爆弾が置かれていない、まっさらな状態」の盤面データが完成しました。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     bombs.fill(true, 0, BOMB_NUM).shuffle();</code></pre>
                <p>先ほど準備した配列の一部をtrue（爆弾である）に書き換えています。</p>
                <p>
                    具体的に言うと、まず bombs.fill(true, 0, BOMB_NUM) で、配列の先頭から BOMB_NUM個（10個）だ
                    けをtrue（肯定を意味します。今回の場合は、爆弾であるという意味になります。）で上書きしています。
                </p>
                <p>次に、.shuffle()で配列の中身をシャッフルし、10個の爆弾をランダムな位置に散らばらせます。</p>
            </div>
            <div class="p-block">
                <p>これで、10個の爆弾がランダムな位置に配置された盤面データが完成しました。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+         //* 追加：パネルに爆弾情報を紐づける
+         panel.isBomb = bombs[spanX * PANEL_NUM_Y + spanY];</code></pre>
                <p>
                    90個のパネルを一つずつ作成するループの中で、そのパネルが爆弾かどうかを判定し、情報を紐付けてい
                    ます。
                </p>
                <p>
                    具体的には、各パネルに isBomb という「爆弾フラグ」を持たせ、bombs配列から対応する情報（trueか
                    false）をセットしています。
                </p>
                <p>
                    しかし、bombs配列は1次元の長い配列であるのに対し、パネルの位置はspanXとspanYという2次元の座
                    標で管理されています。そこで、spanX * PANEL_NUM_Y + spanY という計算を行うことで、2次元の座
                    標を1次元配列のインデックス（何番目か）に変換しています。
                </p>
            </div>
            <div class="p-block">
                <p>
                    それでは、この式の意味について、PANEL_NUM_Yが10で(spanX, spanY)が(2, 5)のマスの時を例として
                    考えていきましょう。
                </p>
                <p>
                    まず、 spanX * PANEL_NUM_Y で、X座標が2の列の直前までに、マスが全部で何個あるか（X=0の列の
                    10個 + X=1の列の10個）を計算しています。
                </p>
                <p>
                    次に、Y座標である5を足すことで、bombs配列の25番目（0から数えるので26番目の要素）のtrue/false
                    を取り出すことができるのです。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+         if (panel.isBomb) Bomb().addChildTo(panel);</code></pre>
                <p>
                    先ほどパネルに紐づけた情報から、もしパネルが爆弾だった場合に、目印となる爆弾の画像を表示していま
                    す。
                </p>
                <p>
                    まず if (panel.isBomb) でそのパネルが爆弾である（つまりisBombがtrueである）かを判定しています。
                    これを<strong>if文</strong>と呼び、if文の条件式にtrueという値が入ると、それに続く処理が実行されます。
                </p>
                <p>
                    もし isBomb が true なら次に、後ほど定義するBombクラスから爆弾の見た目を持つオブジェクトを生成
                    し、addChildTo(panel)でそのパネルの子要素として表示しています。
                </p>
                <p>
                    このように、あるオブジェクトを別のオブジェクトの子要素にすることで、親子で一緒に移動したり、親が
                    消えれば子も一緒に消えたり、といった便利な親子関係を作ることができます。
                </p>
            </div>


            <h4>爆弾クラス (Bomb) の追加</h4>
            <div class="p-block">
                <pre><code class="language-javascript">//* 追加：爆弾クラス
phina.define('Bomb', {
  // Shapeを継承
  superClass: 'Shape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: GRID_SIZE,
        height: GRID_SIZE,
        backgroundColor: 'transparent',
      });
      // 導線
      RectangleShape({
        width: PANEL_SIZE / 8,
        height: PANEL_SIZE / 8,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
        y: -20,
      }).addChildTo(this);
      // 本体
      CircleShape({
        radius: PANEL_SIZE / 4,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
      }).addChildTo(this);
    },
});
//* ここまで</code></pre>
                <p>
                    ここは、爆弾の見た目や動きを定義する、新たなクラスであるbombクラス（設計図）を作成する部分で
                    す。
                </p>
                <p>
                    これまでのクラスと同様に、phina.defineでクラスを定義し、superClassで親クラスを指定、initで初期
                    化処理を記述する、という構成になっています。
                </p>
                <p>
                    Bombクラスの大きな特徴は、initメソッドの中でRectangleShape（四角形）やCircleShape（円）とい
                    った複数の図形パーツを生成し、それらを組み合わせて一つの爆弾オブジェクトを作り上げている点です。
                </p>
            </div>
            <div class="p-block">
                <p>それでは、この bomb の設計図を、一行ずつ詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">//* 追加：爆弾クラス
phina.define('Bomb', {
  // Shapeを継承
  superClass: 'Shape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: GRID_SIZE,
        height: GRID_SIZE,
        backgroundColor: 'transparent',
      });</code></pre>
                <p>ここまでは、これまでのクラスとよく似た構成となっています。</p>
            </div>
            <div class="p-block">
                <p>まずphina.define を利用し、 Bomb という名前の新しいクラス（設計図）を定義しています。</p>
            </div>
            <div class="p-block">
                <p>次に、親クラスとして Shape というクラスを継承しています。</p>
                <p>
                    Shapeクラスは、それ自体は透明なグループのようなものです。この透明な土台の上に、RectangleShape
                    （導線）やCircleShape（本体）といった複数の図形パーツを配置していくことで、複雑な形のオブジェク
                    トを一つにまとめることができます。
                </p>
            </div>
            <div class="p-block">
                <p>そして、init関数で、Bombクラスのコンストラクタ（初期化処理） を行っています。</p>
                <p>
                    その中で、idthとheightでこのBombオブジェクト全体の占有サイズをGRID_SIZEに設定し、また
                    backgroundColorを'transparent'（透明）にしています。これは、後から追加する導線や本体の図形だけ
                    を表示させるための設定です。
                </p>
            </div>
            <div class="p-block">
                <p>ここから、これまでのクラスとは少し違う構成になっていきます。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">      // 導線
      RectangleShape({
        width: PANEL_SIZE / 8,
        height: PANEL_SIZE / 8,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
        y: -20,}).addChildTo(this);</code></pre>
                <p>ここでは、爆弾の「導線」にあたる、小さな四角形のパーツを作成しています。</p>
                <p>
                    RectangleShapeは、new phina.display.RectangleShape({ ... }) の省略形であり、phina.jsで手軽に四
                    角形の図形オブジェクトを生成するための便利な記法です。
                </p>
                <p>
                    その際に、引数として{ ... } の中に設定情報を渡すことで、描画される四角形の見た目を細かく指定するこ
                    とができます。今回は、以下のように設定しています。
                </p>
                <ul>
                    <li>width, height：四角形の大きさを、パネルのサイズを基準に小さく（1/8の大きさに）設定</li>
                    <li>fill：塗りつぶし色を紺色（#000088 ≒ navy）に設定</li>
                    <li>stroke：枠線の色を白（#ffffff ≒ white）に設定</li>
                    <li>y: -20：台紙の中心からY軸方向に-20ピクセルの位置に配置（非常に重要な設定）</li>
                </ul>
                <p>
                    ちなみに、phina.jsでは、多くのグラフィックシステムと同様に、Y軸は下方向がプラスになります。その
                    ため、-20は<strong>上に20ピクセルずらす</strong>という意味になります。
                </p>
            </div>
            <div class="p-block">
                <p>
                    ただし、これだけではまだ「設計図に情報を書き込んだ」だけで、画面には表示されません。
                    .addChildTo(this)でクラスに追加することで、初めて画面に登場します。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">      CircleShape({
        radius: PANEL_SIZE / 4,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
      }).addChildTo(this);</code></pre>
                <p>ここでは、爆弾の「本体」にあたる、円形のパーツを作成しています。</p>
                <p>
                    CircleShapeは、new phina.display.CircleShape({ ... }) の省略形であり、 RectangleShape と同様、
                    phina.jsで手軽に円形の図形オブジェクトを生成するための便利な記法です。
                </p>
                <p>
                    その際に、引数として{ ... } の中に設定情報を渡すことで、描画される円形の見た目を細かく指定すること
                    ができます。今回は、以下のように設定しています。
                </p>
                <ul>
                    <li>
                        radius：円の半径を、パネルのサイズの1/4の大きさ（つまり直径をパネルのサイズの半分の大きさ
                        に）設定
                    </li>
                    <li>fill：塗りつぶし色を紺色（#000088 ≒ navy）に設定</li>
                    <li>stroke：枠線の色を白（#ffffff ≒ white）に設定</li>
                </ul>
            </div>
            <div class="p-block">
                <p>
                    また、 RectangleShape の時と同様に、.addChildTo(this)でクラスに追加することで、初めて画面に登場
                    します。
                </p>
            </div>
            <div class="p-block">
                <p>これで、配置したパネルにランダムに爆弾を配置することができました。</p>
                <p>次のステップではいよいよ、パネルを開いて周りにある爆弾の数が表示される機能を実装します。</p>
            </div>


            <h3>パネルを開く</h3>
            <div class="p-block">
                <p>
                    ここでは、下のスクリーンショットのように、パネルを開いて周りにある爆弾の数が表示されるようにしま
                    す。
                </p>
            </div>
            <div class="p-block">

            <img src="image\Panel-open.png" alt="タイルを開けたスクリーンショット" width="40%" />

            <p>
                以下は、パネルを開けるために、これまでのコードにいくつかの追加と、それに伴う変更を加えたコードで
                す。前回までと同様、コード内の//* 追加や//* 変更と書かれた部分が、今回の変更点です。
            </p>
            <pre><code class="language-javascript">// phina.js をグローバル領域に展開
phina.globalize();

// 定数
var GRID_SIZE = 70; // グリッドのサイズ
var SCREEN_SPACE = 10; // 画面端の空白
var PANEL_NUM_X = 9; // 横のパネル数
var PANEL_NUM_Y = 10; // 縦のパネル数
var PANEL_MARGIN_RATIO = 1.3; // 画面縦の空白の割合
var PANEL_SIZE_RATIO = 0.9; // パネル大きさの割合
var BOMB_NUM = 10; // 爆弾数
var SCREEN_WIDTH = GRID_SIZE * PANEL_NUM_X + SCREEN_SPACE// 画面横サイズ
var SCREEN_HEIGHT = GRID_SIZE * PANEL_NUM_Y * PANEL_MARGIN_RATIO + SCREEN_SPACE; // 画面縦サイズ
var PANEL_SIZE = GRID_SIZE * PANEL_SIZE_RATIO; // パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + SCREEN_SPACE) / 2; // オフセット値

// メインシーン
phina.define('MainScene', {
  superClass: 'DisplayScene',
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = '#808080'; // ≒'gray'
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    // 爆弾位置をランダムに決めた配列を作成
    var bombs = [];
    (PANEL_NUM_X * PANEL_NUM_Y).times(function() {
      bombs.push(false);
    });
    bombs.fill(true, 0, BOMB_NUM).shuffle();

    var self = this; //* 追加
    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
        // パネルに爆弾情報を紐づける
        panel.isBomb = bombs[spanX * PANEL_NUM_Y + spanY];
        //* 追加：開かれているかどうか
        panel.isOpen = false;
        // タッチ有効化
        panel.setInteractive(true);
        // パネルタッチ時
        panel.onpointstart = function() {
          self.openPanel(panel);
        }
        //* ここまで
        // 爆弾なら表示
        if (panel.isBomb) Bomb().addChildTo(panel);
      });
    });
    //* 追加：参照用
    this.panelGroup = panelGroup;
  },

  //* 追加：パネルを開く処理
  openPanel: function(panel) {
    // 既に開かれていた何もしない
    if (panel.isOpen) return;
    // 開いたとフラグを立てる
    panel.isOpen = true;
    // タッチ不可にする
    panel.setInteractive(false);
    
    var bombs = 0;
    var indexs = [-1, 0, 1];
    var self = this;
    // 周りのパネルの爆弾数をカウント
    indexs.each(function(i) {
      indexs.each(function(j) {
        var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
        var target = self.getPanel(pos);
        if (target && target.isBomb) bombs++;
      });
    });
    // パネルに数を表示
    panel.num = bombs === 0 ? '' : bombs;
    Label({
      text: panel.num,
      fill: '#ffffff', // 文字色 ≒'white'
    }).addChildTo(panel);
    panel.fill = '#808080'; // 塗りつぶし色 ≒'gray'
  },
  //* ここまで

  //* 追加：指定された位置のパネルを得る
  getPanel: function(pos) {
    var result = null;
    
    this.panelGroup.children.some(function(panel) {
      if (panel.position.equals(pos)) {
        result = panel;
        return true;
      }
    });
    return result;
    //* ここまで
  },
});

// パネルクラス
phina.define('Panel', {
  // RectangleShapeを継承
  superClass: 'RectangleShape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: '#c0c0c0', // 塗りつぶし色 ≒'silver'
        stroke: '#ffffff', // 枠の色 ≒'white'
        cornerRadius: 2, // 角の丸み
      });
    },
});

// 爆弾クラス
phina.define('Bomb', {
  // Shapeを継承
  superClass: 'Shape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: GRID_SIZE,
        height: GRID_SIZE,
        backgroundColor: 'transparent',
      });
      // 導線
      RectangleShape({
        width: PANEL_SIZE / 8,
        height: PANEL_SIZE / 8,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
        y: -20,
      }).addChildTo(this);
      // 本体
      CircleShape({
        radius: PANEL_SIZE / 4,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
      }).addChildTo(this);
    },
});

// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: 'main', // メイン画面からスタート
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });
  app.run();
});</code></pre>
                <p>このコードをコピーし、 main.jsに上書き、あるいは変更点を追記してください。</p>
            </div>
            <div class="p-block">
                <p>
                    今回は、MainSceneにパネルをクリックした際の動作を定義する、新しい機能（メソッド）を主に追加し
                    ています。
                </p>
                <p>それでは、追加・変更した要素がどのような役割を持っているのか、詳しく見ていきましょう。</p>
            </div>


            <h4>追加部分の確認 - initメソッド</h4>
            <div class="p-block">
                <pre><code class="language-Diff">  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = '#808080'; // 背景色 ≒'gray'
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    // 爆弾位置をランダムに決めた配列を作成
    var bombs = [];
    (PANEL_NUM_X * PANEL_NUM_Y).times(function() {
      bombs.push(false);
    });
    bombs.fill(true, 0, BOMB_NUM).shuffle();

+     var self = this; //* 追加
    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
        // パネルに爆弾情報を紐づける
        panel.isBomb = bombs[spanX * PANEL_NUM_Y + spanY];
+         //* 追加：開かれているかどうか
+         panel.isOpen = false;
+         // タッチ有効化
+         panel.setInteractive(true);
+         // パネルタッチ時
+         panel.onpointstart = function() {
+           self.openPanel(panel);
+         }
+         //* ここまで
        // 爆弾なら表示
        if (panel.isBomb) Bomb().addChildTo(panel);
      });
    });
+     //* 追加：参照用
+     this.panelGroup = panelGroup;
  },</code></pre>
                <p>この部分で、いくつかの追加を行っています。</p>
                <p>まず、後にMainSceneをthisとして参照するために、selfに代入しています。</p>
                <p>
                    次に、パネルが既に開かれているかどうかのフラグ変数と、パネルをタッチできるようにしています。ま
                    た、パネルのタッチイベントが発生した際にopenPanel関数を呼び出すようにしています。
                </p>
                <p>最後にpanelGroupを別の関数からも参照できるようにthis.panelGroupに代入しています。</p>
            </div>
            <div class="p-block">
                <p>それでは、それぞれ抜粋し、詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     var self = this; //* 追加</code></pre>
                <p>ここでは、MainSceneオブジェクト自身を指すthisを、selfという別の変数に一時的に保存しています。</p>
                <p>
                    これは、この後に出てくるpanel.onpointstartのようなコールバック関数（イベント処理など、後から呼
                    び出される関数）の中でthisを使うと、そのthisがMainSceneではなく、別のもの（この場合はクリックさ
                    れたpanel）を指してしまい、MainSceneのメソッド（openPanelなど）を呼び出せなくなる、という
                    JavaScriptの仕様を回避するための、定番のテクニックです。
                </p>
                <p>
                    selfという変数に入れておくことで、コールバック関数の中からでも、確実にMainScene自身を参照でき
                    るようになります。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+         //* 追加：開かれているかどうか
+         panel.isOpen = false;</code></pre>
                <p>
                    作成したパネル一つ一つに、開かれているかどうかのフラグを付け、そこにfalse（つまり開かれていな
                    い）を設定しています。
                </p>
                <p>
                    これにより、後ほどパネルが開かれた際にこの値をtrueに変更すれば、二重にパネルを開いてしまうのを防
                    ぐ処理を追加することができます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+         // タッチ有効化
+         panel.setInteractive(true);</code></pre>
                <p>パネルが、クリック（タッチ）に反応するようにしています。</p>
                <p>
                    これをtrue（肯定、つまり有効化）しておかないと、どんな設定をしても、どれだけクリックしてもうんと
                    もすんとも言いません。必ず有効化しておきましょう。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+         // パネルタッチ時
+         panel.onpointstart = function() {
+           self.openPanel(panel);
+         }</code></pre>
                <p>パネルがクリックされたときに、どんな処理を行うかを記述しています。</p>
            </div>
            <div class="p-block">
                <p>
                    onpointstartは、phina.jsの表示オブジェクトが持つ、特殊なプロパティです。ここに関数（function）
                    を代入しておくことで、そのオブジェクトがクリック（またはタッチ）された瞬間に、代入した関数が自動
                    的に呼び出されます。
                </p>
                <p>
                    このような、特定のイベント発生時に実行されるように登録しておく関数のことを、一般的に「イベントリ
                    スナー」や「イベントハンドラ」と呼びます。
                </p>
                </div>
            <div class="p-block">
                <p>肝心な、イベントリスナーとして登録した関数の中身は、 self.openPanel(panel); だけです。</p>
                <p>
                    これは、self（つまり、MainScene）の持っている、後述の openPanel という名前のメソッドを呼び出し
                    ています。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     //* 追加：参照用
+     this.panelGroup = panelGroup;</code></pre>
                <p>
                    initメソッド内だけで有効なローカル変数のpanelGroupを、MainSceneオブジェクト自身のプロパティに
                    しています。
                </p>
            </div>
            <div class="p-block">
                <p>
                    なぜこれが必要なのかというと、initメソッドの中で var panelGroup = ... と宣言された panelGroup
                    は、ローカル変数と呼ばれ、このinitメソッドの中でしか使えないからです。
                </p>
                <p>
                    この状態で、後ほど作成するgetPanelメソッドなど、initメソッドの外側から panelGroup にアクセス
                    しようとしても、「変数が見つかりません。」とエラーが発生してしまいます。
                </p>
                <p>
                    そこで、 this.panelGroup = panelGroup; と記述することにより、initの外にあるgetPanelメソッドから
                    も、パネルのグループを参照できるようになります。
                </p>
            </div>


            <h4>パネルを開く関数 (openPanel) の追加</h4>
            <div class="p-block">
                <pre><code class="language-javascript">  //* 追加：パネルを開く処理
  openPanel: function(panel) {
    // 既に開かれていた何もしない
    if (panel.isOpen) return;
    // 開いたとフラグを立てる
    panel.isOpen = true;
    // タッチ不可にする
    panel.setInteractive(false);
    
    var bombs = 0;
    var indexs = [-1, 0, 1];
    var self = this;
    // 周りのパネルの爆弾数をカウント
    indexs.each(function(i) {
      indexs.each(function(j) {
        var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
        var target = self.getPanel(pos);
        if (target && target.isBomb) bombs++;
      });
    });
    // パネルに数を表示
    panel.num = bombs === 0 ? '' : bombs;
    Label({
      text: panel.num,
      fill: '#ffffff', // 文字色 ≒'white'
    }).addChildTo(panel);
    panel.fill = '#808080'; // 塗りつぶし色 ≒'gray'
  },
  //* ここまで</code></pre>
                <p>ここでは、MainSceneにopenPanelという新しいメソッド（クラスが持つ関数）を追加しています。</p>
                <p>
                    このメソッドは、先ほど設定したイベントリスナーによって、パネルがクリックされた際に呼び出されま
                    す。引数として、クリックされたpanelオブジェクトそのものを受け取ります。
                </p>
                <p>
                    具体的には、二重開封の防止、状態の更新、周囲の爆弾数のカウント、そして結果（数字や色）の表示を担
                    当します。
                </p>
            </div>
            <div class="p-block">
                <p>それでは、この一連の処理を、詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">  //* 追加：パネルを開く処理
  openPanel: function(panel) {</code></pre>
                <p>
                    先ほどonpointstartの中で呼び出したself.openPanel(panel)の、openPanelメソッド本体をここで定義し
                    ています。
                </p>
                <p>
                    MainSceneクラスに、openPanelという名前の新しい機能（メソッド）を追加する、というイメージで
                    す。
                </p>
                <p>
                    function(panel)の部分からわかる通り、onpointstartから呼び出す際に渡された、クリックされたpanel
                    オブジェクトを、このメソッドは引数として受け取ることができます。これにより、このメソッドの中で
                    は、引数panelを操作することで、クリックされた特定のパネルに対して処理を行えるようになります。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    // 既に開かれていた何もしない
    if (panel.isOpen) return;</code></pre>
                <p>
                    openPanelメソッドの最初に、もしこのパネルが既に開かれていたら（つまり isOpen が true なら）、こ
                    の先の処理は一切行わずにここで終了しなさい。という命令を記述しています。</p>
                <p><strong>return;</strong>は、関数やメソッドの処理をその場で中断し、呼び出し元に戻るための命令です。</p>
            </div>
            <div class="p-block">
                <p>
                    このように、関数の冒頭で「処理を行うべきでない条件」を判定し、条件に一致したらすぐに処理を終了さ
                    せる書き方を「ガード節」や「早期リターン」と呼びます。これにより、メインの処理を不必要なifの入れ
                    子から解放し、コード全体をスッキリさせることができます。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    // 開いたとフラグを立てる
    panel.isOpen = true;</code></pre>
                <p>
                    ガード節を抜けた（＝まだ開かれていない）パネルに対して、isOpenプロパティの値をtrue（開いた）に
                    更新しています。
                </p>
                <p>
                    一度trueに更新しておくことで、次に同じパネルがクリックされた際に、冒頭のガード節（if
                    (panel.isOpen) return;）が機能し、二重開封が正しく防止されるのです。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    // タッチ不可にする
    panel.setInteractive(false);</code></pre>
                <p>
                    一度開いたパネルは、もうクリック（タッチ）される必要がありません。そこで、setInteractive(false)を
                    呼び出し、このパネルのインタラクティブな状態を解除（OFFに）します。
                </p>
                <p>
                    これは、意図しない操作を防ぐだけでなく、無駄なクリック判定処理を減らすことにも繋がり、ゲーム全体
                    のパフォーマンスをわずかに向上させる効果もあります。
                </p>
                <p>
                    不要になったイベントリスナーは、こまめにOFFにする習慣をつけておくのが良いでしょう。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    var bombs = 0;</code></pre>
                <p>
                    クリックされたパネルの周囲にある爆弾の数を数えるための、カウンター用変数 bombs を用意していま
                    す。
                </p>
                <p>
                    まずは0を初期値として設定しておきます。これから周囲のパネルを一つずつチェックし、爆弾を見つける
                    たびに、この数値を1ずつ増やしていくことになります。
                </p>
            </div>
            <div class="p-block">
                <p>
                    このように、計算を始める前にカウンターを0にリセット（初期化）するのは、プログラミングにおける基
                    本的なお作法です。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    var indexs = [-1, 0, 1];</code></pre>
                <p>
                    クリックされたパネルの周囲8方向と、中心（自分自身）の合計9マスを調べるための、便利な配列を用意
                    しています。
                </p>
                <p>
                    このindexs配列を、この後に出てくる二重ループで使うことで、中心のパネルからの「相対的な位置」を
                    簡単に作り出すことができます。
                </p>
                <p>
                    例えば、ループ変数iとjがそれぞれ-1, 0, 1と変化することで、(i, j)の組み合わせは(-1,-1)(左上), (-1,0)
                    (左), ..., (1,1)(右下)の9パターンを網羅します。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    var self = this;</code></pre>
                <p>initメソッドの時にも登場した、thisが指す対象が変わってしまう問題を避けるためのおまじないです。</p>
                <p>
                    この後で使うeachメソッドのコールバック関数（function）の中では、thisがMainSceneを指さなくなっ
                    てしまいます。
                </p>
                <p>
                    そのため、あらかじめMainScene自身を指しているthisを、変数selfに退避させています。これにより、コ
                    ールバック関数の内側からでも、selfを使って安全にMainSceneのメソッド（getPanelなど）を呼び出せ
                    るようになります。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    indexs.each(function(i) {
      indexs.each(function(j) {</code></pre>
                <p>
                    先ほど用意したindexs配列（[-1, 0, 1]）を使い、周囲9マスを調べるための二重ループ処理を行っていま
                    す。
                </p>
                <p>
                    n.timesが0, 1, 2, ...という連番を生成するのに対し、ここで使われている<strong>.each()</strong>は、配列の要素を一つず
                    つ順番に取り出して処理を行うための、phina.jsの便利なメソッドです。つまりこの場合は、iにもjに
                    も-1, 0, 1が順番に入るということです。
                </p>
                <p>
                    これにより、(i, j)の組み合わせは、先ほど確認した(-1, -1)から(1, 1)までの9パターンすべてが網羅される
                    ことになります。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">        var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);</code></pre>
                <p>
                    クリックされたパネルの座標(panel.x, panel.y)を基準に、調べるべき周囲のパネルの座標を計算していま
                    す。
                </p>
                <p>
                    また、Vector2(x, y)とは、X座標とY座標のペアをまとめて管理できる、phina.jsの便利なベクトルオブジ
                    ェクトのことです。位置や速度、力の向きなどを表現するのによく使われます。
                </p>
            </div>
            <div class="p-block">
                <p>まず、中心となるパネルのX座標を基準にします。これが panel.x です。</p>
                <p>
                    次に、相対位置i（-1, 0, 1のいずれか）に、1マス分の大きさGRID_SIZEを掛け算します。これにより、
                    「左に1マス分」「動かない」「右に1マス分」という、具体的な移動量が計算できます。これが i * GRID_SIZE です。
                </p>
                <p>
                    最後に、panel.x + i * GRID_SIZE で、この2つを足し合わせることで、調べるべきパネルのX座標が求ま
                    ります。
                </p>
                <p>Y座標も同様の考え方で計算することができます。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">        var target = self.getPanel(pos);</code></pre>
                <p>
                    先ほど計算した座標（pos）を元に、後ほど作成するgetPanelメソッドを使って、その位置に存在するパネ
                    ルオブジェクトを探し出しています。
                </p>
                <p>
                    その座標にパネルが存在すれば、target変数には、見つかったパネルオブジェクトが入ります。しかし、盤
                    面の外など、その座標にパネルが存在しなければ、target変数には<strong>null（何もない）</strong>が入ります。
                </p>
                <p>
                    このtarget変数を次のif文で使うことで、盤面の範囲外をチェックしてしまうエラーを防ぎます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">        if (target && target.isBomb) bombs++;</code></pre>
                <p>このif文で、見つかったtargetが「存在する」かつ「爆弾である」かどうかを判定しています。</p>
                </div>
            <div class="p-block">
                <p>
                    まず、targetでその位置にパネルが本当に存在するかを確認しています（盤面の端だと存在しない場合があ
                    るため）。
                </p>
                <p>次に、target.isBombで見つかったパネルが爆弾であるかを確認します。</p>
                <p>両方の条件を満たした場合にのみ、爆弾カウンターbombsの数を1つ増やします。</p>
            </div>
            <div class="p-block">
                <p>
                    また、その間にある&&は、「A and B」のように、両方の条件がtrueの場合にのみ、全体をtrueと評価す
                    る演算子です。
                </p>
                <p>
                    重要な特徴として、左側の条件（target）がfalse（またはnullなどfalseと見なされる値）だった場合、右
                    側の条件（target.isBomb）は評価すらされずに処理が終了します。 これを「短絡評価」と呼びます。
                </p>
                <p>
                    このおかげで、targetがnullの場合にnull.isBombという存在しないプロパティにアクセスしてエラーにな
                    る、という事態を安全に回避できます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    // パネルに数を表示
    panel.num = bombs === 0 ? '' : bombs;</code></pre>
                <p>周囲の爆弾をすべて数え終えたら、その結果をパネルに記録しています。</p>
            </div>
            <div class="p-block">
                <p>
                    ここで使われている 条件 ? A : B という書き方は、三項演算子と呼ばれる、if文の省略形です。「もし条件
                    がtrueならAを、falseならBを実行（代入）しなさい」という意味になります。
                </p>
                <p>
                    今回のコードに当てはめてみると、「もし、周囲の爆弾の数（bombs）が0と等しい（===）なら、
                    panel.numに空の文字列（''）を、そうでなければbombsの数そのものを代入しなさい」という処理になり
                    ます。
                </p>
                <p>
                    なぜ爆弾が0個の時に0ではなく空の文字列（''）にしているかというと、マインスイーパのルールでは、周
                    りに爆弾がないマスには数字を表示しないからです。この一行で、そのルールをスマートに実装しているわ
                    けです。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    Label({
      text: panel.num,
      fill: '#ffffff', // 文字色 ≒'white'
    }).addChildTo(panel);</code></pre>
                <p>
                    phina.jsのLabelクラスを使って、表示する数字のオブジェクトを生成しています。それぞれ以下のように
                    設定しています。
                </p>
                <ul>
                    <li>text: panel.num：表示するテキストを、先ほど決めたpanel.numの値に設定</li>
                    <li>fill: '#ffffff': 文字の色を白（#ffffff ≒ white）に設定。</li>
                </ul>
            </div>
            <div class="p-block">
                <p>
                    そして、最後に.addChildTo(panel)で、作成したLabelオブジェクトを、MainScene（this）ではなく、
                    panelオブジェクト自身の子要素として追加しています。
                </p>
                <p>
                    これにより、数字のラベルがパネルの中央に表示され、今後もしパネルが動くようなことがあっても、数字
                    はパネルと一緒に移動するようになります。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    panel.fill = '#808080'; // 塗りつぶし色 ≒'gray'</code></pre>
                <p>最後に、開かれたパネル自体の塗りつぶし色を灰色(#808080 ≒ gray)に変更しています。</p>
                <p>
                    これにより、プレイヤーは視覚的にどのパネルが開かれたのかを瞬時に判別できるようになり、ゲームの操
                    作性が向上します
                </p>
            </div>


            <h4>パネル捜索関数（getPanel）の追加</h4>
            <div class="p-block">
                <pre><code class="language-javascript">  //* 追加：指定された位置のパネルを得る
  getPanel: function(pos) {
    var result = null;
    
    this.panelGroup.children.some(function(panel) {
      if (panel.position.equals(pos)) {
        result = panel;
        return true;
      }
    });
    return result;
    //* ここまで</code></pre>
                <p>ここでは、MainSceneにgetPanelという新しいメソッドを追加しています。</p>
                <p>
                    このメソッドは、先ほど作成したopenPanelメソッドの中で「指定した座標に、どのパネルが存在する
                    か」を探し出すために使われる、補助的な役割を持っています。
                </p>
                <p>
                    引数としてpos（Vector2オブジェクトで表された座標）を受け取り、その座標にピッタリ一致するパネル
                    オブジェクトを探し出して返します。もし見つからなければnull（何もない）を返します。
                </p>
            </div>
            <div class="p-block">
                <p>それでは、このメソッドがどのようにしてパネルを探し出しているのか、その中身を見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">  getPanel: function(pos) {</code></pre>
                <p>
                    openPanelメソッドの中で呼び出したself.getPanel(pos)の、getPanelメソッド本体を、先ほどと同様
                    に、ここで定義しています。
                </p>
                <p>このメソッドの役割は、「指定された座標にどのパネルがあるかを探し出す」ことです。</p>
                <p>
                    function(pos)の部分で、openPanelから渡された探したいパネルの座標情報（Vector2オブジェクト）
                    を、引数posとして受け取っています。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    var result = null;</code></pre>
                <p>
                    getPanelメソッドの返り値（戻り値）を格納するための変数resultを用意し、初期値としてnullを代入して
                    います。
                </p>
                <p>nullは、「何もない」「空っぽ」を意味する特殊な値です。</p>
                <p>
                    このように、関数の最初に結果格納用の変数をnull（または0や空文字など）で初期化しておき、条件に一
                    致した場合にだけその変数に値を上書きし、最後にその変数を返す、という処理の流れは、プログラミング
                    で非常によく使われる基本的なパターンの一つです。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    this.panelGroup.children.some(function(panel) {</code></pre>
                <p>
                    この一行で、90個すべてのパネルを一つずつチェックし、「指定された座標と一致するパネル」を探し出
                    しています。コードが長いので、.（ドット）で区切って、左から順番に見ていきましょう。
                </p>
            </div>
            <div class="p-block">
                <p>
                    まず、 this.panelGroup は initメソッド でプロパティとして保存しておいた、パネルのグループ全体を参
                    照しています。
                </p>
                <p>
                    次に、.childrenプロパティにアクセスします。ここには、panelGroupの中に含まれているすべての子要
                    素（今回は90個のパネルオブジェクト）が、配列として格納されています。
                </p>
                <p>最後に、.some(function(panel) { ... })で、その配列に対して.some()メソッドを実行します。</p>
            </div>
            <div class="p-block">
                <p>
                    .some()は、配列の要素を一つずつ取り出し、{}の中に書かれた処理を順番に実行していく、JavaScriptの
                    便利な繰り返しメソッドです。しかし、ひとつ特殊なルールがあり、それが{}内の処理が一度でもtrueを返
                    した時点で、繰り返しを即座に中断するというものです。
                </p>
                <p>
                    今回のように「たくさんの中から、条件に合うものを1つだけ見つけたい」という場合に、無駄なループ処
                    理を省けるため、非常に効率的なのです。（もし一度もtrueを返さなければ、someメソッド自身はfalseを
                    返します）
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">      if (panel.position.equals(pos)) {
        result = panel;
        return true;
      }</code></pre>
                <p>
                    まず if (panel.position.equals(pos)) で、panel.position（今チェックしているパネルの座標）と、引数
                    で受け取ったpos（探している座標）が、X座標とY座標の両方とも完全に一致しているかを判定します。
                </p>
                <p>
                    phina.jsのVector2オブジェクト同士を比較する際は、==ではなく、この.equals()メソッドを使うのが定
                    石です。
                </p>
            </div>
            <div class="p-block">
                <p>もし座標が一致した場合（.equals()がtrueを返した場合）、ifブロックの中の処理が実行されます。</p>
                <p>
                    まず result = panel で、最初 null だったresult変数に、見つかったパネルオブジェクトそのものを代入し
                    ます。これで、捜索結果を保持できます。
                </p>
                <p>
                    return true 次のこれが非常に重要です。 true を返すことで、.some()メソッドに対して「探していたもの
                    が見つかったので、もうループを中断してOKです」と伝えています。
                </p>
                <p>これにより、残りのパネルをチェックする無駄な処理を省略できます。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    return result;</code></pre>
                <p>someメソッドのループがすべて終わった後、最終的にこのgetPanelメソッドが返す値を決定します。</p>
                <p>
                    パネルが見つかった場合は、ループの途中でresultにパネルオブジェクトが代入されているので、そのパネ
                    ルオブジェクトが返されます。
                </p>
                <p>
                    ただし、パネルが見つからなかった場合は、ループは最後まで中断されず、resultの中身は初期値の<strong>nullの
                    まま</strong>です。そのため、nullが返されます。
                </p>
            </div>
            <div class="p-block">
                <p>これで、パネルを開いて周囲の爆弾数を表示する、ゲームの基本的な機能が実装できました。</p>
                <p>次のステップでは、マインスイーパ特有の「連鎖オープン」機能を実装していきます。</p>
            </div>


            <h3>パネルを連鎖で開く</h3>
            <div class="p-block">
                <p>
                    ここでは、下のスクリーンショットのように、周りに爆弾がない場合にパネルを連鎖で開くようにします。
                </p>
            </div>
            <div class="p-block">

            <img src="image\Panel-chain-open.png" alt="タイルを連鎖で開けたスクリーンショット" width="40%" />

            <p>
                以下は、パネルを連鎖的に開けるために、これまでのコードにいくつかの追加と、それに伴う変更を加えた
                コードです。これまでと同様、コード内の//* 追加や//* 変更と書かれた部分が、今回の変更点です。
            </p>
            <pre><code class="language-javascript">// phina.js をグローバル領域に展開
phina.globalize();

// 定数
var GRID_SIZE = 70; // グリッドのサイズ
var SCREEN_SPACE = 10; // 画面端の空白
var PANEL_NUM_X = 9; // 横のパネル数
var PANEL_NUM_Y = 10; // 縦のパネル数
var PANEL_MARGIN_RATIO = 1.3; // 画面縦の空白の割合
var PANEL_SIZE_RATIO = 0.9; // パネル大きさの割合
var BOMB_NUM = 10; // 爆弾数
var SCREEN_WIDTH = GRID_SIZE * PANEL_NUM_X + SCREEN_SPACE// 画面横サイズ
var SCREEN_HEIGHT = GRID_SIZE * PANEL_NUM_Y * PANEL_MARGIN_RATIO + SCREEN_SPACE; // 画面縦サイズ
var PANEL_SIZE = GRID_SIZE * PANEL_SIZE_RATIO; // パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + SCREEN_SPACE) / 2; // オフセット値

// メインシーン
phina.define('MainScene', {
  superClass: 'DisplayScene',
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = '#808080'; // 背景色 ≒'gray'
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    // 爆弾位置をランダムに決めた配列を作成
    var bombs = [];
    (PANEL_NUM_X * PANEL_NUM_Y).times(function() {
      bombs.push(false);
    });
    bombs.fill(true, 0, BOMB_NUM).shuffle();

    var self = this;
    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
        // パネルに爆弾情報を紐づける
        panel.isBomb = bombs[spanX * PANEL_NUM_Y + spanY];
        // 開かれているかどうか
        panel.isOpen = false;
        // タッチ有効化
        panel.setInteractive(true);
        // パネルタッチ時
        panel.onpointstart = function() {
          self.openPanel(panel);
        }
        // 爆弾なら表示
        if (panel.isBomb) Bomb().addChildTo(panel);
      });
    });
    // 参照用
    this.panelGroup = panelGroup;
  },

  // パネルを開く処理
  openPanel: function(panel) {
    // 既に開かれていた何もしない
    if (panel.isOpen) return;
    // 開いたとフラグを立てる
    panel.isOpen = true;
    // タッチ不可にする
    panel.setInteractive(false);

    var bombs = 0;
    var indexs = [-1, 0, 1];
    var self = this;
    // 周りのパネルの爆弾数をカウント
    indexs.each(function(i) {
      indexs.each(function(j) {
        var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
        var target = self.getPanel(pos);
        if (target && target.isBomb) bombs++;
      });
    });
    // パネルに数を表示
    panel.num = bombs === 0 ? '' : bombs;
    Label({
      text: panel.num,
      fill: '#ffffff', // 文字色 ≒'white'
    }).addChildTo(panel);
    panel.fill = '#808080'; // 塗りつぶし色 ≒'gray'
    //* 追加：周りに爆弾がなければ再帰的に調べる
    if (bombs === 0) {
      indexs.each(function(i) {
        indexs.each(function(j) {
          var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
          var target = self.getPanel(pos);
          target && self.openPanel(target);
        });
      });
    }
    //* ここまで
  },

  // 指定された位置のパネルを得る
  getPanel: function(pos) {
    var result = null;
    
    this.panelGroup.children.some(function(panel) {
      if (panel.position.equals(pos)) {
        result = panel;
        return true;
      }
    });
    return result;
  },
});

// パネルクラス
phina.define('Panel', {
  // RectangleShapeを継承
  superClass: 'RectangleShape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: '#c0c0c0', // 塗りつぶし色 ≒'silver'
        stroke: '#ffffff', // 枠の色 ≒'white'
        cornerRadius: 2, // 角の丸み
      });
    },
});

// 爆弾クラス
phina.define('Bomb', {
  // Shapeを継承
  superClass: 'Shape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: GRID_SIZE,
        height: GRID_SIZE,
        backgroundColor: 'transparent',
      });
      // 導線
      RectangleShape({
        width: PANEL_SIZE / 8,
        height: PANEL_SIZE / 8,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
        y: -20,
      }).addChildTo(this);
      // 本体
      CircleShape({
        radius: PANEL_SIZE / 4,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
      }).addChildTo(this);
    },
});

// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: 'main', // メイン画面からスタート
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });
  app.run();
});</code></pre>
                <p>このコードをコピーし、 main.jsに上書き、あるいは変更点を追記してください。</p>
            </div>
            <div class="p-block">
                <p>
                    今回の変更点は一箇所のみです。openPanelメソッドの中で、「もし開いたパネルの周囲の爆弾数が0だっ
                    たら、その周りの8方向のパネルに対しても、自分自身（openPanel）を呼び出す」という処理を追加しま
                    す。
                </p>
                <p>それでは、追加・変更した要素がどのような役割を持っているのか、詳しく見ていきましょう。</p>
            </div>


            <h4>周りに爆弾がない場合の処理の追加</h4>
            <div class="code-block">
                <pre><code class="language-javascript">    //* 追加：周りに爆弾がなければ再帰的に調べる
    if (bombs === 0) {
      indexs.each(function(i) {
        indexs.each(function(j) {
          var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
          var target = self.getPanel(pos);
          target && self.openPanel(target);
        });
      });
    }
    //* ここまで</code></pre>
                <p>openPanelメソッドの最後に、if (bombs === 0)というifブロックを追加しています。</p>
                <p>このとき、まず「クリックされたパネルの周囲の爆弾数が0だった場合」という条件で分岐します。</p>
                <p>
                    次に、条件に一致した場合、以前にも使った二重ループで、周囲8方向のパネルを一つずつチェックしてい
                    きます。
                </p>
                <p>
                    そして、 target && self.openPanel(target); が、この機能の心臓部です。target（隣のパネル）が存在す
                    る場合に、その隣のパネルに対して、自分自身であるopenPanelメソッドを再度呼び出しています。
                </p>
            </div>
            <div class="p-block">
                <p>なぜ、これが連鎖になるのかを段階的に説明していきます。</p>
                <p>
                    まず、Aというパネル（爆弾数0）が開かれます。そのAは、隣にあるパネルBに対してopenPanel(B)を呼
                    び出します。
                </p>
                <p>
                    呼び出されたBも爆弾数が0だった場合、Bはさらにその隣のパネルCに対してopenPanel(C)を呼び出しま
                    す。
                </p>
                <p>
                    そこで、もしCの爆弾数が1だった場合、Cは数字を表示して処理を終了します。すると、処理はBに戻り、
                    Bはまた別の隣のパネルの処理を続け...
                </p>
            </div>
            <div class="p-block">
                <p>
                    このように、「爆弾数が0だったら、隣のパネルを開く」という処理が、まるでドミノ倒しのように次々と
                    伝播していくことで、あの連鎖オープンが実現されているのです。
                </p>
                <p>
                    この、あるメソッドが自分自身を呼び出すテクニックを「再帰呼び出し」と呼び、複雑な処理を非常にシン
                    プルに記述できる、強力な手法です。
                </p>
            </div>
            <div class="p-block">
                <p>
                    それでは、このメソッドがどのようにしてパネルを連鎖的に開いていっているのか、その中身をさらに詳し
                    く見ていきましょう。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    //* 追加：周りに爆弾がなければ再帰的に調べる
    if (bombs === 0) {</code></pre>
                <p>このif文は、再帰呼び出しを続けるか、止めるかを決定する、非常に重要な条件分岐です。</p>
                <p>
                    bombs === 0、つまり「周囲の爆弾が0個」という条件を満たした場合にのみ、さらに周囲のパネルを開
                    く処理（再帰呼び出し）が実行されます。
                </p>
                <p>
                    逆に、周囲に1つでも爆弾があるパネルは、この条件を満たさないため、ここで処理が終了します。これ
                    が、再帰の無限ループを防ぎ、連鎖を正しく停止させるための「終了条件」の役割を果たしているのです。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">      indexs.each(function(i) {
        indexs.each(function(j) {</code></pre>
                <p>
                    if文の条件を満たした場合、openPanelメソッドの前半で使ったのと全く同じ二重ループ処理で、周囲9マ
                    スを再度チェックしていきます。
                </p>
                <p>
                    このループで、先ほど確認した(-1, -1)から(1, 1)までの9パターンの相対位置をすべて網羅し、次に開くべ
                    き隣接パネルを一つずつ特定していきます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">          var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);</code></pre>
                <p>こちらも、openPanelメソッドの前半で登場したのと全く同じ計算式です。</p>
                <p>
                    中心となるパネル（panel）の座標を基準に、ループで生成した相対位置（i, j）を使って、調べるべき周囲
                    のパネルの絶対座標を算出しています。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">          var target = self.getPanel(pos);</code></pre>
                <p>これも、openPanelメソッドの前半部分と全く同じ処理です。</p>
                <p>
                    計算した座標（pos）を、自作のヘルパーメソッドであるgetPanelに渡すことで、その位置に対応するパネ
                    ルオブジェクトを取得しています。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">          target && self.openPanel(target);</code></pre>
                <p>これがこの機能の心臓部であり、「再帰呼び出し」が行われている部分です。</p>
                <p>
                    まず、 target && ... で target が null でないこと（盤面の端などで、パネルがちゃんと存在すること）を
                    確認しています。
                </p>
                <p>
                    ここで重要なのは、呼び出された側のopenPanelメソッドも、必ず冒頭のif (panel.isOpen) return;とい
                    うガード節から処理を開始するという点です。
                </p>
                <p>
                    一度開かれたパネルに対しては、このガード節が機能して即座に処理が終了するため、同じパネルを何度も
                    開いて無限ループに陥る、という事態が防がれています。
                </p>
                <p>
                    この「終了条件（ガード節）」と「再帰呼び出し」の組み合わせが、安全で強力な再帰処理を実現している
                    のです。
                </p>
            </div>
            <div class="p-block">
                <p>これで、周囲に爆弾がない場合にパネルが連鎖して開く、マインスイーパの最も特徴的ともいえるような機能が実装できました。</p>
                <p>次のステップでは、ついにマインスイーパの勝敗を決める、ゲームオーバーとクリア処理を追加します。</p>
            </div>


            <h3>ゲームオーバーとクリア処理</h3>
            <div class="p-block">
                <p>
                    ここでは、下のスクリーンショットのように、ゲームオーバーの処理とゲームクリアの処理を追加していきます。
                </p>
            </div>
            <div class="p-block">

            <img src="image\gameover_Screen.png" alt="ゲームオーバー時のスクリーンショット" width="40%" />

            <p>
                以下は、ゲームオーバーとゲームクリアの処理のために、これまでのコードにいくつかの追加と、それに伴う変更を加えた
                コードです。これまでと同様、コード内の//* 追加や//* 変更と書かれた部分が、今回の変更点です。
            </p>
            <pre><code class="language-javascript">// phina.js をグローバル領域に展開
phina.globalize();

// 定数
var GRID_SIZE = 70; // グリッドのサイズ
var SCREEN_SPACE = 10; // 画面端の空白
var PANEL_NUM_X = 9; // 横のパネル数
var PANEL_NUM_Y = 10; // 縦のパネル数
var PANEL_MARGIN_RATIO = 1.3; // 画面縦の空白の割合
var PANEL_SIZE_RATIO = 0.9; // パネル大きさの割合
var BOMB_NUM = 10; // 爆弾数
var SCREEN_WIDTH = GRID_SIZE * PANEL_NUM_X + SCREEN_SPACE// 画面横サイズ
var SCREEN_HEIGHT = GRID_SIZE * PANEL_NUM_Y * PANEL_MARGIN_RATIO + SCREEN_SPACE; // 画面縦サイズ
var PANEL_SIZE = GRID_SIZE * PANEL_SIZE_RATIO; // パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + SCREEN_SPACE) / 2; // オフセット値

// メインシーン
phina.define('MainScene', {
  superClass: 'DisplayScene',
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = '#808080'; // 背景色 ≒'gray'
    //* 追加：タッチ不可に
    this.setInteractive(false);
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    // 爆弾位置をランダムに決めた配列を作成
    var bombs = [];
    (PANEL_NUM_X * PANEL_NUM_Y).times(function() {
      bombs.push(false);
    });
    bombs.fill(true, 0, BOMB_NUM).shuffle();

    var self = this;
    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
        // パネルに爆弾情報を紐づける
        panel.isBomb = bombs[spanX * PANEL_NUM_Y + spanY];
        // 開かれているかどうか
        panel.isOpen = false;
        // タッチ有効化
        panel.setInteractive(true);
        // パネルタッチ時
        panel.onpointstart = function() {
          self.openPanel(panel);
          //* 追加：クリア判定
          if (self.oCount === PANEL_NUM_X * PANEL_NUM_Y - BOMB_NUM) {
            // ラベル表示
            Label({
              text: 'GOOD JOB!',
              fill: 'white',
            }).addChildTo(self).setPosition(SCREEN_WIDTH / 2, SCREEN_HEIGHT * (PANEL_MARGIN_RATIO + 1) / (PANEL_MARGIN_RATIO * 2));
            // パネルを選択不可に
            self.panelGroup.children.each(function(panel) {
              panel.setInteractive(false);
            });
          }
          //* ここまで
        };
        //! 削除：爆弾なら表示
        //if (panel.isBomb) Bomb().addChildTo(panel);
      });
    });
    // 参照用
    this.panelGroup = panelGroup;
    //* 追加：クリア判定用
    this.oCount = 0;
  },
    //* 追加：画面タッチ可能な場合
  onpointstart: function() {
    // 再スタート
    this.exit({
      nextLabel: 'main',  
    });  
  },
  //* ここまで
  // パネルを開く処理
  openPanel: function(panel) {
    //* 追加：爆弾ならゲームオーバー
    if (panel.isBomb) {
      Explosion().addChildTo(panel);
      this.showAllBombs();
      return;
    }
    //* ここまで
    // 既に開かれていた何もしない
    if (panel.isOpen) return;
    // 開いたとフラグを立てる
    panel.isOpen = true;
    this.oCount++; //* 追加
    // タッチ不可にする
    panel.setInteractive(false);

    var bombs = 0;
    var indexs = [-1, 0, 1];
    var self = this;
    // 周りのパネルの爆弾数をカウント
    indexs.each(function(i) {
      indexs.each(function(j) {
        var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
        var target = self.getPanel(pos);
        if (target && target.isBomb) bombs++;
      });
    });
    // パネルに数を表示
    panel.num = bombs === 0 ? '' : bombs;
    Label({
      text: panel.num,
      fill: '#ffffff', // 文字色 ≒'white'
    }).addChildTo(panel);
    panel.fill = '#808080'; // 塗りつぶし色 ≒'gray'
    // 周りに爆弾がなければ再帰的に調べる
    if (bombs === 0) {
      indexs.each(function(i) {
        indexs.each(function(j) {
          var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
          var target = self.getPanel(pos);
          target && self.openPanel(target);
        });
      });
    }
  },

  // 指定された位置のパネルを得る
  getPanel: function(pos) {
    var result = null;
    
    this.panelGroup.children.some(function(panel) {
      if (panel.position.equals(pos)) {
        result = panel;
        return true;
      }
    });
    return result;
  },

  //* 追加：爆弾を全て表示する
  showAllBombs: function() {
    var self = this;

    this.panelGroup.children.each(function(panel) {
      panel.setInteractive(false);

      if (panel.isBomb) {
        Bomb().addChildTo(panel);
        panel.tweener.clear().scaleTo(1.2, 100)
                     .scaleTo(1.0, 100)
                     .call(function() {
                        // ラベル表示
                        Label({
                          text: 'TOUCH TO RESTART',
                          fill: 'white',
                        }).addChildTo(self).setPosition(SCREEN_WIDTH / 2, SCREEN_HEIGHT * (PANEL_MARGIN_RATIO + 1) / (PANEL_MARGIN_RATIO * 2));
                        // 画面をタッチ可能に
                        self.setInteractive(true);
                     });
      }
    });
  },
  //* ここまで
});

// パネルクラス
phina.define('Panel', {
  // RectangleShapeを継承
  superClass: 'RectangleShape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: '#c0c0c0', // 塗りつぶし色 ≒'silver'
        stroke: '#ffffff', // 枠の色 ≒'white'
        cornerRadius: 2, // 角の丸み
      });
    },
});

// 爆弾クラス
phina.define('Bomb', {
  // Shapeを継承
  superClass: 'Shape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: GRID_SIZE,
        height: GRID_SIZE,
        backgroundColor: 'transparent',
      });
      // 導線
      RectangleShape({
        width: PANEL_SIZE / 8,
        height: PANEL_SIZE / 8,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
        y: -20,
      }).addChildTo(this);
      // 本体
      CircleShape({
        radius: PANEL_SIZE / 4,
        fill: "#000088", // 塗りつぶし色 ≒'navy'
        stroke: '#ffffff', // 枠の色 ≒'white'
      }).addChildTo(this);
    },
});

//* 追加：爆発クラス
phina.define('Explosion', {
  // StarShapeを継承
  superClass: 'StarShape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        radius: (PANEL_SIZE + 5) / 2,
        sides: 10,
        sideIndent: 0.75,
        rotation: 15,
        fill: "red",
        stroke: "yellow",
      });
    },
});
//* ここまで

// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: 'main', // メイン画面からスタート
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });
  app.run();
});</code></pre>
                <p>このコードをコピーし、 main.jsに上書き、あるいは変更点を追記してください。</p>
            </div>
            <div class="p-block">
                <p>今回は、ゲームとしての勝敗判定や演出を加えるため、多くの追加・変更を行っています。</p>
                <p>まず、爆弾パネルをクリックした際に、すべての爆弾を表示し、リスタートを促す機能を追加します。</p>
                <p>そして、爆弾以外のすべてのパネルを開いた際に、クリアメッセージを表示する機能を追加します。</p>
                <p>さらに、ゲーム開始時に爆弾が見えないように、表示処理をopenPanelメソッド内に移動します。</p>
                <p>最後に、ゲームオーバー時に爆発エフェクトを表示する、新しいExplosionクラスを追加します。</p>
                <p>
                    <span class="underline-orange">
                        注： 今回のステップのコードは、参考にさせていただいたサイトのものを元にしていますが、サイト側の
                        分割解説では省略されていた部分も含まれています。このチュートリアルでは、その部分も含めて詳しく解
                        説していきます。
                    </span>
                </p>
            </div>
            <div class="p-block">
                <p>それでは、追加・変更した要素がどのような役割を持っているのか、詳しく見ていきましょう。</p>
            </div>


            <h4>追加部分の確認 - MainScene_initメソッド</h4>
            <div class="code-block">
                <pre><code class="language-Diff">  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = '#808080'; // 背景色 ≒'gray'
+     //* 追加：タッチ不可に
+     this.setInteractive(false);
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_X, PANEL_NUM_X);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    // 爆弾位置をランダムに決めた配列を作成
    var bombs = [];
    (PANEL_NUM_X * PANEL_NUM_Y).times(function() {
      bombs.push(false);
    });
    bombs.fill(true, 0, BOMB_NUM).shuffle();</code></pre>
                <p>initメソッドの、パネルを配置するループ処理が始まる前の部分に、一行だけコードが追加されました。</p>
                <p>この変更は、ゲームが終了した後のリスタート機能に関わる、重要な準備作業です。</p>
                <p>それでは、この追加された一行がどのような役割を持っているのか、詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     //* 追加：タッチ不可に
+     this.setInteractive(false);</code></pre>
                <p>initメソッドの冒頭で、MainScene自身をクリック（タッチ）できないように設定しています。</p>
                <p>この一行は、この後のゲームオーバー処理やクリア処理を実装する上での、重要な伏線となります。</p>
            </div>
            <div class="p-block">
                <p>
                    なぜ、最初にOFFにするのかというと、ゲームをプレイしている最中にクリックに反応してほしいのは、
                    個々の「パネル」であって、背景である「シーン」ではないからです。もしシーンがクリックに反応してし
                    まうと、意図しない動作の原因になってしまいます。
                </p>
                <p>
                    そこで、まずゲーム開始時点では、シーン自身はクリックできないようにfalse（OFF）に設定しておきま
                    す。
                </p>
                <p>
                    そして、ゲームオーバーやゲームクリアが表示された後に、この設定をtrue（ON）に切り替えることで、
                    初めて「画面のどこかをタッチしてリスタート」という機能を実現できるのです。
                </p>
            </div>
            <div class="p-block">
                <p>
                    このコードは、元の参考サイトでは解説が省略されていましたが、ゲームのリスタート機能を正しく実装す
                    るために不可欠な一行です。
                </p>
            </div>


            <h4>追加部分の確認 - ピース配置メソッド</h4>
            <div class="p-block">
                <pre><code class="language-Diff">    // ピース配置
    PANEL_NUM_X.times(function(spanX) {
      PANEL_NUM_Y.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
        // パネルに爆弾情報を紐づける
        panel.isBomb = bombs[spanX * PANEL_NUM_Y + spanY];
        // 開かれているかどうか
        panel.isOpen = false;
        // タッチ有効化
        panel.setInteractive(true);
        // パネルタッチ時
        panel.onpointstart = function() {
          self.openPanel(panel);
+           //* 追加：クリア判定
+           if (self.oCount === PANEL_NUM_X * PANEL_NUM_Y - BOMB_NUM) {
+             // ラベル表示
+             Label({
+               text: 'GOOD JOB!',
+               fill: 'white',
+             }).addChildTo(self).setPosition(SCREEN_WIDTH / 2, SCREEN_HEIGHT * (PANEL_MARGIN_RATIO + 1) / (PANEL_MARGIN_RATIO * 2));
+             // パネルを選択不可に
+             self.panelGroup.children.each(function(panel) {
+               panel.setInteractive(false);
+             });
+           }
+           //* ここまで
        };
-         //! 削除：爆弾なら表示
-         //if (panel.isBomb) Bomb().addChildTo(panel);
      });
    });</code></pre>
                <p>
                    パネルを90個配置する二重ループの中では、2つの重要な変更を行っています。それが、ゲームクリア判定
                    処理の追加と、ゲーム開始時の爆弾表示処理の削除です。
                </p>
                <p>
                    これらは、マインスイーパを「ゲーム」として成立させるための、非常に重要な変更です。それぞれ詳しく
                    見ていきましょう。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+           //* 追加：クリア判定
+           if (self.oCount === PANEL_NUM_X * PANEL_NUM_Y - BOMB_NUM) {</code></pre>
                <p>
                    パネルを開くopenPanelメソッドを呼び出した直後に、このif文でゲームクリアの条件を満たしたかどうか
                    を毎回チェックしています。
                </p>
                <p>ここで、===（等しい）の左右を比較している内容は、以下の通りです。</p>
            </div>
            <div class="p-block">
                <p>
                    self.oCount は、後ほど定義する「開かれたパネルの数を数えるカウンター」です。パネルが1枚開かれる
                    たびに、このカウンターの数が1ずつ増えていきます。
                </p>
                <p>
                    PANEL_NUM_X * PANEL_NUM_Y - BOMB_NUM これは、「爆弾ではないパネルの総数」を計算してい
                    ます。（全体のパネル数 90個 - 爆弾の数 10個 = 80個）
                </p>
            </div>
            <div class="p-block">
                <p>
                    つまり、このif文は「開かれたパネルの数」と「安全なパネルの総数」が等しくなったかどうかを判定して
                    いるのです。
                </p>
                <p>
                    この条件が満たされた瞬間、それはつまり「すべての安全なパネルが開かれた」ことを意味し、ゲームクリ
                    アとなります。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+             Label({
+               ...
+             }).addChildTo(self).setPosition(SCREEN_WIDTH / 2, SCREEN_HEIGHT * (PANEL_MARGIN_RATIO + 1) / (PANEL_MARGIN_RATIO * 2));</code></pre>
                <p>クリアメッセージのラベルを表示する位置を、.setPosition()メソッドで指定しています。</p>
                <p>
                    .setPosition()には引数としてX座標とY座標を渡しますが、今回は特にY座標の計算が少し複雑になってい
                    ます。
                </p>
            </div>
            <div class="p-block">
                <p>
                    まず、 SCREEN_WIDTH / 2 はシンプルに、画面の横幅のちょうど半分の位置を指します。これにより、
                    ラベルは左右方向の中央に配置されます。
                </p>
                <p>
                    次の、 SCREEN_HEIGHT * (PANEL_MARGIN_RATIO + 1) / (PANEL_MARGIN_RATIO * 2) の一見
                    複雑な計算式は、ゲーム盤面の下にある余白スペースの、ちょうど真ん中の高さを正確に算出するためのも
                    のです。
                </p>
                <p>
                    私たちは以前、SCREEN_HEIGHTを定義する際に、PANEL_MARGIN_RATIO（1.3）を使って、パネル
                    全体の高さに加えて30%分の余白を追加しました。この計算式は、その余白部分だけを正確に計算し、そ
                    の中心座標を割り出しています。
                </p>
                <p>
                    これにより、ラベルがゲーム盤面に重なることなく、画面下部の空きスペースに常にバランス良く表示され
                    るようになっています。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+               text: 'GOOD JOB!',
+               fill: 'white',</code></pre>
                <p>Labelクラスに渡す設定情報です。</p>
                <p>textプロパティで、画面に表示する文字列を「GOOD JOB!」に指定しています。</p>
                <p>fillプロパティでは、そのテキストの色を白（#ffffff ≒ white）に指定しています。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+             // パネルを選択不可に
+             self.panelGroup.children.each(function(panel) {
+               panel.setInteractive(false);
+             });</code></pre>
                <p>
                    ゲームがクリアされたときに、もうそれ以上パネルをクリックできないように、すべてのパネルを操作不能
                    な状態にしています。
                </p>
                <p>
                    self.panelGroup.childrenで、90個すべてのパネルが格納された配列にアクセスし、.each()メソッドを使
                    って、パネルを一つずつ順番に処理していきます。
                </p>
                <p>
                    そして、ループの中でpanel.setInteractive(false)を実行することで、個々のパネルのインタラクティブ状
                    態をOFFにしています。
                </p>
            </div>
            <div class="p-block">
                <p>
                    これにより、クリアメッセージが表示された後に、プレイヤーが誤って他のパネルをクリックしてしまうの
                    を防ぎます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">-         //! 削除：爆弾なら表示
-         //if (panel.isBomb) Bomb().addChildTo(panel);</code></pre>
                <p>
                    最後に、これまでデバッグ（動作確認）のために使っていた、ゲーム開始時にすべての爆弾を表示する処理
                    を削除します。
                </p>
                <p>マインスイーパは、本来どこに爆弾があるか分からない状態でスタートするゲームです。</p>
                <p>
                    この一行を削除することで、初めてプレイヤーが爆弾の位置を知らないという、本来あるべきゲームの形が
                    完成します。爆弾は、パネルが開かれた時に（それが爆弾だった場合に）初めて表示されるようになりま
                    す。
                </p>
            </div>


            <h4>追加部分の確認 - ピース配置メソッド直後</h4>
            <div class="p-block">
                <pre><code class="language-Diff">    // 参照用
    this.panelGroup = panelGroup;
+     //* 追加：クリア判定用
+     this.oCount = 0;
  },
+     //* 追加：画面タッチ可能な場合
+   onpointstart: function() {
+     // 再スタート
+     this.exit({
+       nextLabel: 'main',
+     });
+   },
+   //* ここまで</code></pre>
                <p>
                    initメソッドの最後にクリア判定用のカウンターを追加し、さらにinitメソッドの外（MainSceneクラスの
                    直下）に、リスタート機能のためのonpointstartメソッドを新しく追加しています。
                </p>
                <p>
                    これらは、それぞれ「ゲームクリア」と「ゲームオーバー」の判定や、その後の流れを制御するための重要
                    な部品です。
                </p>
                <p>それでは、これらの追加部分について、一つずつ詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     //* 追加：クリア判定用
+     this.oCount = 0;</code></pre>
                <p>
                    initメソッドの最後に、this.oCountという新しいプロパティを追加し、初期値として0を設定していま
                    す。
                </p>
                <p>
                    これは、開かれたパネルの数を数えるためのカウンターです。oCountは "open count" の略だと考えると
                    分かりやすいでしょう。
                </p>
                <p>
                    initメソッドが実行されるゲーム開始時点では、まだパネルは一つも開かれていないため、0で初期化して
                    おきます。
                </p>
                <p>
                    後ほど、openPanelメソッドの中でパネルが1枚開かれるたびに、このカウンターの値を1ずつ加算してい
                    きます。そして、このoCountの値が「爆弾ではないパネルの総数」と一致した瞬間に、ゲームクリアとな
                    るわけです。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     //* 追加：画面タッチ可能な場合
+   onpointstart: function() {</code></pre>
                <p>MainSceneクラスに、onpointstartという新しいメソッドを追加しています。</p>
                <p>
                    個々のパネルが持っていたonpointstartが「パネルがクリックされた時」の処理だったのに対し、
                    MainSceneが持つこのonpointstartは、「シーン全体（背景など、パネル以外の部分）がクリックされた
                    時」に実行される処理を定義します。
                </p>
                <p>
                    ゲームオーバーの後、私たちはMainSceneのsetInteractiveをtrueに戻す処理を実装します。その結果、こ
                    のonpointstartが有効になり、「画面のどこかをタッチしてリスタート」という機能が実現できるので
                    す。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     // 再スタート
+     this.exit({
+       nextLabel: 'main',
+     });</code></pre>
                <p>onpointstartメソッドの中で、実際にリスタート処理を行っている部分です</p>
                <p>
                    this.exit()は、現在のシーン（この場合はMainScene）を終了させるための、phina.jsが用意しているメ
                    ソッドです。
                </p>
                <p>引数として渡している { nextLabel: 'main' } が、シーン終了後の挙動を決定しています。</p>
            </div>
            <div class="p-block">
                <p>
                    また、nextLabelプロパティは、次に開始するシーンのラベルを指定するためのものです。ここで
                    は'main'を指定することで、「現在のMainSceneを終了した後、もう一度'main'というラベルを持つシー
                    ン、つまりMainScene自身を開始しなさい」という命令になります。
                </p>
                <p>
                    この一連の流れにより、現在のゲーム画面がリセットされ、新しいMainSceneが最初から作り直されるた
                    め、ゲームのリスタートが実現されるのです。
                </p>
            </div>


            <h4>追加部分の確認 - パネルを開くメソッド</h4>
            <div class="p-block">
                <pre><code class="language-Diff">  // パネルを開く処理
  openPanel: function(panel) {
+     //* 追加：爆弾ならゲームオーバー
+     if (panel.isBomb) {
+       Explosion().addChildTo(panel);
+       this.showAllBombs();
+       return;
+     }
+     //* ここまで
    // 既に開かれていた何もしない
    if (panel.isOpen) return;
    // 開いたとフラグを立てる
    panel.isOpen = true;
+     this.oCount++; //* 追加
    // タッチ不可にする</code></pre>
                <p>
                    プレーヤーの行動に応じて勝敗を判定するため、openPanelメソッドの冒頭部分に2つの処理を追加してい
                    ます。
                </p>
                <p>ひとつは、クリックしたパネルが爆弾だった場合にゲームオーバーとする処理です。</p>
                <p>
                    もうひとつは、パネルが無事に開かれた場合に、ゲームクリアを判定するためのカウンター
                    （this.oCount）の数を1つ増やす処理です。
                </p>
            </div>
            <div class="p-block">
                <p>
                    これまで「ただパネルが開くだけ」だったこのメソッドに、ゲームとしてのルールが加わりました。それで
                    は、これらの追加部分を詳しく見ていきましょう。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     //* 追加：爆弾ならゲームオーバー
+     if (panel.isBomb) {</code></pre>
                <p>
                    openPanelメソッドの処理が始まった直後に、まずこのif文で「クリックされたパネルが爆弾かどうか」を
                    判定しています。
                </p>
                <p>
                    panel.isBombプロパティがtrueだった場合、それはプレイヤーが爆弾のマスをクリックしてしまったこと
                    を意味します。
                </p>
                <p>その場合、{}の中に書かれたゲームオーバーのための一連の処理が実行されることになります。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+       Explosion().addChildTo(panel);
+       this.showAllBombs();
+       return;</code></pre>
                <p>ifブロックの中で、ゲームオーバーのための一連の処理を記述しています。</p>
            </div>
            <div class="p-block">
                <p>
                    最初の Explosion().addChildTo(panel) は、後ほど定義するExplosionクラス（爆発エフェクト）のオブ
                    ジェクトを生成し、クリックされたpanelの子要素として追加しています。これにより、爆弾を踏んだパネ
                    ル上で爆発のアニメーションが表示されます。
                </p>
                <p>
                    次の this.showAllBombs() は、この後で作成する、盤面に隠されているすべての爆弾を表示するための新
                    しいメソッドを呼び出しています。
                </p>
                <p>
                    そして最後の return; が非常に重要です。ゲームオーバーが確定したので、このreturn;によって
                    openPanelメソッドの処理を<strong>ここで完全に中断</strong>します。これにより、この後にあるパネルを開いたり、数
                    字を表示したりする処理が一切実行されるのを防いでいます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-Diff">+     this.oCount++; //* 追加</code></pre>
                <p>
                    ゲームオーバー判定と、二重開封防止のガード節を無事に通過した、つまり「まだ開かれていない、安全な
                    パネル」が開かれた場合に、この処理が実行されます。
                </p>
                <p>
                    this.oCount++ は、initメソッドで0に初期化したカウンター this.oCount の値を1増やす、という意味で
                    す。
                </p>
            </div>
            <div class="p-block">
                <p>
                    この一行は、元の参考サイトでは解説が省略されていましたが、開かれたパネルの数を正確に数えるために
                    不可欠な処理です。
                </p>
                <p>
                    パネルが1枚開かれるたびにこのカウンターを増やしていくことで、initメソッドの中で追加したゲームク
                    リア判定（if (self.oCount === ...)）が正しく機能するようになります。
                </p>
            </div>


            <h4>爆弾をすべて表示するメソッド (showAllBombs) の追加</h4>
            <div class="p-block">
                <pre><code class="language-javascript">  //* 追加：爆弾を全て表示する
  showAllBombs: function() {
    var self = this;

    this.panelGroup.children.each(function(panel) {
      panel.setInteractive(false);

      if (panel.isBomb) {
        Bomb().addChildTo(panel);
        panel.tweener.clear().scaleTo(1.2, 100)
                     .scaleTo(1.0, 100)
                     .call(function() {
                        // ラベル表示
                        Label({
                          text: 'TOUCH TO RESTART',
                          fill: '#ffffff', // 文字色 ≒'white'
                        }).addChildTo(self).setPosition(SCREEN_WIDTH / 2, SCREEN_HEIGHT * (PANEL_MARGIN_RATIO + 1) / (PANEL_MARGIN_RATIO * 2));
                        // 画面をタッチ可能に
                        self.setInteractive(true);
                     });
      }
    });
  },
  //* ここまで</code></pre>
                <p>MainSceneに、showAllBombsという新しいメソッドを追加しています。</p>
                <p>
                    このメソッドは、先ほどopenPanelのゲームオーバー処理の中から呼び出しました。その名の通り、盤面
                    に隠されているすべての爆弾を表示し、プレイヤーに敗北を知らせる演出を担当します。
                </p>
            </div>
            <div class="p-block">
                <p>
                    具体的には、まず90個すべてのパネルをループでチェックし、操作不能な状態にします。その中で、もし
                    パネルが爆弾だった場合は、Bombオブジェクトを表示し、短いアニメーションでプレイヤーの注意を引き
                    ます。
                </p>
                <p>
                    そして、アニメーションが終わったタイミングで「TOUCH TO RESTART」というメッセージを表示し、
                    画面全体をクリックしてリスタートできる状態に移行させます。
                </p>
            </div>
            <div class="p-block">
                <p>それでは、このゲームオーバー演出の流れを、詳しく見ていきましょう。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">  //* 追加：爆弾を全て表示する
  showAllBombs: function() {
    var self = this;</code></pre>
                <p>
                    まず、openPanelメソッドの中で呼び出したthis.showAllBombs()の、showAllBombsメソッド本体をこ
                    こで定義しています。
                </p>
                <p>そして、メソッドの最初に、これまでの解説でも登場した「おまじない」を記述しています。</p>
            </div>
            <div class="p-block">
                <p>
                    この後で使う.each()や.call()といったコールバック関数の中では、thisがMainSceneを指さなくなってし
                    まいます。そのため、あらかじめMainScene自身を指しているthisを、変数selfに退避させています。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">    this.panelGroup.children.each(function(panel) {
      panel.setInteractive(false);</code></pre>
                <p>
                    まず、this.panelGroup.childrenで90個すべてのパネルが格納された配列にアクセスし、.each()メソッ
                    ドでパネルを一つずつ順番に処理していきます。
                </p>
                <p>そして、ループの中で、すべてのパネルに対してsetInteractive(false)を実行しています。</p>
            </div>
            <div class="p-block">
                <p>
                    ゲームオーバーが確定したので、プレイヤーがこれ以上他のパネルをクリックできないように、盤面全体を
                    フリーズ（操作不能に）させるための処理です。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">      if (panel.isBomb) {
        Bomb().addChildTo(panel);</code></pre>
                <p>
                    まず、ループの中で、今チェックしているパネルが爆弾かどうか（isBombプロパティがtrueか）を判定し
                    ています。
                </p>
                <p>
                    ループの中では、もしそのパネルが爆弾だった場合、Bombクラスのオブジェクトを生成し、そのパネルの
                    子要素として追加します。
                </p>
            </div>
            <div class="p-block">
                <p>これにより、これまで隠されていたすべての爆弾が、盤面上で一斉に姿を現すことになります。</p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">        panel.tweener.clear().scaleTo(1.2, 100)
                     .scaleTo(1.0, 100)
                     .call(function() {</code></pre>
                <p>爆弾を表示した後、さらにプレイヤーの注意を引くための短いアニメーションを加えています。</p>
            </div>
            <div class="p-block">
                <p>ここでは、メソッドチェーンを使って、以下のアニメーションを順番に実行しています。</p>
                <ul>
                    <li>
                        .clear()：以前もし何かアニメーションが設定されていた場合に備え、それを一旦すべてリセットし
                        ます。
                    </li>
                    <li>.scaleTo(1.2, 100)：100ミリ秒（0.1秒）かけて、パネルの大きさを1.2倍に拡大します。</li>
                    <li>.scaleTo(1.0, 100)：次に、100ミリ秒かけて、パネルの大きさを元のサイズ（1.0倍）に戻します。</li>
                </ul>
                <p>
                    この2つの.scaleToの連続実行により、爆弾パネルが「<strong>ブルッ</strong>」と一度だけ震えるような、小気味よいアニ
                    メーションが実現されます。
                </p>
            </div>
            <div class="p-block">
                <p>
                    そして最後の .call(function() { ... })は、上記のすべてのアニメーションが完了した<strong>後</strong>に、引数として渡
                    された関数を実行しなさい、という命令です。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">                        // ラベル表示
                        Label({
                          text: 'TOUCH TO RESTART',
                          fill: '#ffffff', // 文字色 ≒'white'
                        }).addChildTo(self).setPosition(SCREEN_WIDTH / 2, SCREEN_HEIGHT * (PANEL_MARGIN_RATIO + 1) / (PANEL_MARGIN_RATIO * 2));</code></pre>
                <p>爆弾のアニメーションがすべて完了したタイミングで、この処理が実行されます。</p>
                <p>まず、Labelクラスを使い、「TOUCH TO RESTART」というテキストを表示しています。</p>
                <p>このコードは、ゲームクリア時に「GOOD JOB!」というラベルを表示した時と、ほとんど同じです。</p>
                <p>
                    textプロパティに表示したい文字列を指定し、.addChildTo(self)でMainSceneに追加、そして
                    .setPosition()で、以前と同じ計算式を使って盤面の下にある余白スペースの中央に配置しています。
                </p>
            </div>
            <div class="p-block">
                <p>
                    これにより、プレイヤーにゲームが終了したことと、次のアクション（画面タッチでリスタート）を明確に
                    伝えます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">                        // 画面をタッチ可能に
                        self.setInteractive(true);</code></pre>
                <p>
                    リスタートメッセージを表示した後、MainScene自身のインタラクティブ状態をtrue（ON）に切り替えて
                    います。
                </p>
                <p>
                    initメソッドの冒頭で、私たちはthis.setInteractive(false)を実行し、ゲームプレイ中はシーン自体がクリ
                    ックに反応しないように設定しました。
                </p>
                <p>ここでその設定をtrueに戻すことで、初めてMainSceneが持つonpointstartメソッドが有効になります。</p>
                <p>
                    これにより、プレイヤーが画面のどこかをタッチすると、先ほど定義したリスタート処理（this.exit(
                    nextLabel: 'main' })）が実行されるようになるのです。
                </p>
            </div>


            <h4>爆破クラス (Explosion) の追加</h4>
            <div class="p-block">
                <pre><code class="language-javascript">//* 追加：爆発クラス
phina.define('Explosion', {
  // StarShapeを継承
  superClass: 'StarShape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        radius: (PANEL_SIZE + 5) / 2,
        sides: 10,
        sideIndent: 0.75,
        rotation: 15,
        fill: '#ff0000', // 塗りつぶし色 ≒'red'
        stroke: '#ffff00', // 枠の色 ≒'yellow'
      });
    },
});
//* ここまで</code></pre>
                <p>
                    最後に、ゲームオーバー時に表示される爆発エフェクトの見た目を定義する、新しいExplosionクラスを作
                    成します。
                </p>
                <p>このクラスの基本的な構造は、これまでに作成したPanelクラスやBombクラスとよく似ています。</p>
                <p>
                    phina.defineでクラスを定義し、superClassで親クラスを継承、initコンストラクタの中でsuperInitを呼
                    び出して、オブジェクトの基本的な見た目を設定しています。
                </p>
                <p>
                    今回は、親クラスとしてphina.jsが用意している**StarShape（星形）**を継承することで、ギザギザとし
                    た爆発らしい形を手軽に実現しています。
                </p>
            </div>
            <div class="p-block">
                <p>
                    それでは、superInitに渡しているプロパティが、それぞれどのような意味を持っているのかを詳しく見て
                    いきましょう。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">//* 追加：爆発クラス
phina.define('Explosion', {
  // StarShapeを継承
  superClass: 'StarShape',
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        ...
      })
    },
});</code></pre>
                <p>
                    まず、これまでのクラスと同様に、phina.defineを使ってExplosionという名前の新しいクラスを定義し
                    ています。
                </p>
                <p>
                    次に、親クラスとして、phina.jsが標準で用意しているStarShape（星形を描画するクラス）を継承してい
                    ます。
                </p>
                <p>
                    RectangleShapeが四角形、CircleShapeが円を描画したように、StarShapeを継承することで、私たちは
                    複雑な計算をすることなく、手軽にギザギザとした星形のオブジェクトを作ることができます。
                </p>
            </div>
            <div class="p-block">
                <p>
                    最後に、initコンストラクタの中で、superInitを呼び出し、この星形の具体的な見た目（大きさや色な
                    ど）を設定していきます。
                </p>
            </div>

            <div class="code-block">
                <pre><code class="language-javascript">        radius: (PANEL_SIZE + 5) / 2,
        sides: 10,
        sideIndent: 0.75,
        rotation: 15,
        fill: '#ff0000', // 塗りつぶし色 ≒'red'
        stroke: '#ffff00', // 枠の色 ≒'yellow'</code></pre>
                <p>initコンスト-ラクタの中で、superInitを呼び出し、StarShapeの見た目を設定しています。</p>
                <p>
                    StarShapeには、星の形をカスタマイズするための、いくつかのユニークなプロパティが用意されていま
                    す。
                </p>
            </div>
            <div class="p-block">
                <p>
                    radius: (PANEL_SIZE + 5) / 2 で星の外側の頂点までの半径を指定します。ここでは、パネルのサイズよ
                    り少しだけ大きい半径に設定することで、パネル全体を覆うような大きさの爆発エフェクトにしています。
                </p>
                <p>
                    sides: 10 で星の頂点の数を指定します。5にすれば五芒星に、今回は10にすることで、よりギザギザの多
                    い形にしています。
                </p>
                <p>
                    sideIndent: 0.75 で星の谷の深さを、0から1の間の割合で指定します。値が1に近いほど、鋭く尖った星形
                    になります。
                </p>
                <p>
                    rotation: 15 で星全体の初期回転角度を度数法で指定します。0だと頂点が真上に来ますが、少し回転させ
                    ることで、よりランダムな爆発の印象を与えます。
                </p>
                <p>
                    fill: 'red', stroke: 'yellow' で最後に、塗りつぶし色を赤色（#ff0000 ≒ red）、枠線の色を黄色
                    （#ffff00 ≒ yellow）に設定し、いかにも爆発らしい、派手な見た目に仕上げています。
                </p>
            </div>
            <div class="p-block">
                <p>これで、ゲームオーバーとゲームクリアの要素が実装され、ゲームとして遊べるレベルまで完成しました。</p>
                <p>
                    さて、これまでの長い道のり、お疲れ様でした。次のステップでは、マインスイーパではかかせないマーク
                    機能を追加します。マーク機能とは、自分で爆弾と判断したパネルをマークして開けないようにする機能
                    のことです。
                </p>
            </div>






            <div class="production-time">
                <p >（現時点の）制作時間：50時間</p>
            </div>
            <!-- ここまでで本文終了 -->

        </div>


        <!--* コピーボタン作成用コードのため、操作不要 -->
        <script>
        // コピーボタン作成用コード
        (function(d){
            const pre = d.querySelectorAll('pre');
            if(pre.length == 0){
                return
            }
            for(let i = 0; i < pre.length; i++){
                const btn = d.createElement('button');
                btn.className = 'copy-button';
                btn.textContent = 'Copy Code';
                pre[i].insertBefore(btn, pre[i].firstElementChild);
                btn.addEventListener('click', copy_code, false)
            }
        })(document);

        // コピー機能用コード
        function copy_code(){
            const code = this.nextElementSibling.innerText;
            if(navigator.clipboard){
                navigator.clipboard.writeText(code).then(() => {
                    this.textContent = 'Copied';
                    setTimeout(() => {
                        this.textContent = 'Copy Code Again'
                    }, 500)
                }).catch(e => {
                    alert('コピーできませんでした\nお手数ですが手動でコピーしてください\n\n' + e.message)
                })
            } else{
                alert('このブラウザは Clipboard API 非対応です\nお手数ですが手動でコピーしてください')
            }
        }
        </script>
    </body>
</html>

